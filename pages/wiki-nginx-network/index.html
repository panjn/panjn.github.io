<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>一文了解 Nginx 高性能网络工作原理 - 面向问题编程</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="面向问题编程"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="面向问题编程"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="大家好，我是飞哥!   在单进程的网络编程模型中。所有的网络相关的动作都是在一个进程里完成的，如监听 socket 的创建， bind、listen。再比如 epoll 的创建、要监听事件的添加，以及 epoll_wait 等待时间发生。这些统统都是在一个进程里搞定。 一个客户端和使用了 epoll 的服务端的交互过程如下图所示。"><meta property="og:type" content="blog"><meta property="og:title" content="一文了解 Nginx 高性能网络工作原理"><meta property="og:url" content="https://www.heapoverflow.cn/pages/wiki-nginx-network/"><meta property="og:site_name" content="面向问题编程"><meta property="og:description" content="大家好，我是飞哥!   在单进程的网络编程模型中。所有的网络相关的动作都是在一个进程里完成的，如监听 socket 的创建， bind、listen。再比如 epoll 的创建、要监听事件的添加，以及 epoll_wait 等待时间发生。这些统统都是在一个进程里搞定。 一个客户端和使用了 epoll 的服务端的交互过程如下图所示。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.heapoverflow.cn/img/wiki-nginx-network/0.jpg"><meta property="article:published_time" content="2022-04-11T01:59:39.204Z"><meta property="article:modified_time" content="2022-04-11T02:02:47.189Z"><meta property="article:author" content="面向问题编程"><meta property="article:tag" content="Linux网络"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/wiki-nginx-network/0.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.heapoverflow.cn/pages/wiki-nginx-network/"},"headline":"一文了解 Nginx 高性能网络工作原理","image":["https://www.heapoverflow.cn/img/wiki-nginx-network/0.jpg"],"datePublished":"2022-04-11T01:59:39.204Z","dateModified":"2022-04-11T02:02:47.189Z","author":{"@type":"Person","name":"面向问题编程"},"publisher":{"@type":"Organization","name":"面向问题编程","logo":{"@type":"ImageObject","url":"https://www.heapoverflow.cn/img/logo.svg"}},"description":"大家好，我是飞哥!   在单进程的网络编程模型中。所有的网络相关的动作都是在一个进程里完成的，如监听 socket 的创建， bind、listen。再比如 epoll 的创建、要监听事件的添加，以及 epoll_wait 等待时间发生。这些统统都是在一个进程里搞定。 一个客户端和使用了 epoll 的服务端的交互过程如下图所示。"}</script><link rel="canonical" href="https://www.heapoverflow.cn/pages/wiki-nginx-network/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-ETGL163DQH" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-ETGL163DQH');</script><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-6757924689439593" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="面向问题编程" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories/%E9%97%AE%E9%A2%98/">问题</a><a class="navbar-item" href="/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/">技术架构</a><a class="navbar-item" href="/categories/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3/">一文了解</a></div><div class="navbar-end"><a class="navbar-item" rel="noopener" title="分类" href="/categories">分类</a><a class="navbar-item" rel="noopener" title="标签" href="/tags">标签</a><a class="navbar-item" rel="noopener" title="归档" href="/archives">归档</a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/wiki-nginx-network/0.jpg" alt="一文了解 Nginx 高性能网络工作原理"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-11T01:59:39.204Z" title="2022/4/11 上午9:59:39">2022-04-11</time>发表</span><span class="level-item"><time dateTime="2022-04-11T02:02:47.189Z" title="2022/4/11 上午10:02:47">2022-04-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3/">一文了解</a></span><span class="level-item">33 分钟读完 (大约4895个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">一文了解 Nginx 高性能网络工作原理</h1><div class="content"><p>大家好，我是飞哥!  </p>
<p>在单进程的网络编程模型中。所有的网络相关的动作都是在一个进程里完成的，如监听 socket 的创建， bind、listen。再比如 epoll 的创建、要监听事件的添加，以及 epoll_wait 等待时间发生。这些统统都是在一个进程里搞定。</p>
<p>一个客户端和使用了 epoll 的服务端的交互过程如下图所示。</p>
<span id="more"></span>

<p><img src="/img/wiki-nginx-network/0.jpg"></p>
<p>以下是其大概的代码示例（没耐心看的同学可以先）。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123; <span class="comment">//监听 lfd = socket(AF_INET,SOCK_STREAM,0); bind(lfd, ...) listen(lfd, ...);</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//创建epoll对象，并把 listen socket的事件管理起来</span></span><br><span class="line"> efd = epoll_create(...);</span><br><span class="line"> epoll_ctl(efd, EPOLL_CTL_ADD, lfd, ...);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//事件循环</span></span><br><span class="line"> <span class="keyword">for</span> (;;)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="type">size_t</span> nready = epoll_wait(efd, ep, ...);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nready; ++i)&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(ep[i].data.fd == lfd)&#123;</span><br><span class="line">    <span class="comment">//lfd上发生事件表示都连接到达，accept接收它</span></span><br><span class="line">    fd = accept(listenfd, ...);</span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_ADD, fd, ...);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//其它socket发生的事件都是读写请求、或者关闭连接</span></span><br><span class="line">    ...</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在单进程模型中，不管有多少的连接，是几万还是几十万，服务器都是通过 epoll 来监控这些连接 socket 上的可读和可写事件。当某个 socket 上有数据发生的时候，再以非阻塞的方式对 socket 进行读写操作。</p>
<p>事实上，Redis 5.0 及以前的版本中，它的网络部分去掉对 handler 的封装，去掉时间事件以后，代码基本和上述 demo 非常接近。而且因为 Redis 的业务特点只需要内存 IO，且 CPU 计算少，所以可以达到数万的 QPS。</p>
<p><img src="/img/wiki-nginx-network/1.jpg"></p>
<p>但是单进程的问题也是显而易见的，没有办法充分发挥多核的优势。所以目前业界绝大部分的后端服务还都是需要基于多进程的方式来进行开发的。到了多进程的时候，更复杂的问题多进程之间的配合和协作问题就产生了。比如  </p>
<ul>
<li>哪个进程执行监听 listen ，以及 accept 接收新连接？</li>
<li>哪个进程负责发现用户连接上的读写事件？</li>
<li>当有用户请求到达的时候，如何均匀地将请求分散到不同的进程中？</li>
<li>需不需要单独搞一部分进程执行计算工作</li>
<li>…</li>
</ul>
<p>事实上，以上这些问题并没有标准答案。各大应用或者网络框架都有自己不同的实现方式。为此业界还专门总结出了两类网络设计模式 - Reactor 和 Proactor。不过今天我不想讨论这种抽象模式，而是想带大家看一个具体的 Case - Nginx 是如何在多进程下使用 epoll 的。</p>
<h2 id="一、-Nginx-Master-进程初始化"><a href="#一、-Nginx-Master-进程初始化" class="headerlink" title="一、 Nginx Master 进程初始化"></a>一、 Nginx Master 进程初始化</h2><p>在 Nginx 中，将进程分成了两类。一类是 Master 进程，一类是 Worker 进程。</p>
<p>在 Master 进程中，主要的任务是负责启动整个程序、读取配置文件、监听和处理各种信号，并对 Worker 进程进行统筹管理。</p>
<p>不过今天我们要查看的重点问题是看网络。在 Master 进程中，和网络相关的操作非常简单就是创建了 socket 并对其进行 bind 和 监听。</p>
<p><img src="/img/wiki-nginx-network/2.jpg"></p>
<p>具体细节我们来看 Main 函数。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/core/nginx.c</span></span><br><span class="line"><span class="type">int</span> ngx_cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> *argv)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">ngx_cycle_t</span>      *cycle, init_cycle;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//1.1 ngx_init_cycle 中开启监听</span></span><br><span class="line"> cycle = ngx_init_cycle(&amp;init_cycle);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//1.2 启动主进程循环</span></span><br><span class="line"> ngx_master_process_cycle(cycle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Nginx 中，ngx_cycle_t 是非常核心的一个结构体。这个结构体存储了很多东西，也贯穿了好多的函数。其中对端口的 bind 和 listen 就是在它执行时完成的。</p>
<p>ngx_master_process_cycle 是 Master 进程的主事件循环。它先是根据配置启动指定数量的 Worker 进程，然后就开始关注和处理重启、退出等信号。接下来我们分两个小节来更详细地看。</p>
<h3 id="1-1-Nginx-的服务端口监听"><a href="#1-1-Nginx-的服务端口监听" class="headerlink" title="1.1 Nginx 的服务端口监听"></a>1.1 Nginx 的服务端口监听</h3><p>我们看下 ngx_init_cycle 中是如何执行 bind 和 listen 的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/core/ngx_cycle.c</span></span><br><span class="line"><span class="type">ngx_cycle_t</span> *<span class="title function_">ngx_init_cycle</span><span class="params">(<span class="type">ngx_cycle_t</span> *old_cycle)</span></span><br><span class="line">&#123;</span><br><span class="line"> ......</span><br><span class="line"> <span class="keyword">if</span> (ngx_open_listening_sockets(cycle) != NGX_OK) &#123;</span><br><span class="line">  <span class="keyword">goto</span> failed;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正的监听还是在 ngx_open_listening_sockets 函数中，继续看它的源码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/core/ngx_connection.c</span></span><br><span class="line"><span class="type">ngx_int_t</span> <span class="title function_">ngx_open_listening_sockets</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle)</span></span><br><span class="line">&#123;</span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="comment">//要监听的 socket 对象</span></span><br><span class="line"> ls = cycle-&gt;listening.elts;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cycle-&gt;listening.nelts; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取第i个socket</span></span><br><span class="line">  s = ngx_socket(ls[i].sockaddr-&gt;sa_family, ls[i].type, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//绑定</span></span><br><span class="line">  bind(s, ls[i].sockaddr, ls[i].socklen)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//监听</span></span><br><span class="line">  listen(s, ls[i].backlog)</span><br><span class="line">  ls[i].listen = <span class="number">1</span>;</span><br><span class="line">  ls[i].fd = s;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个函数中，遍历要监听的 socket。如果是启用了 REUSEPORT 配置，那先把 socket 设置上 SO_REUSEPORT 选项。然后接下来就是大家都熟悉的 bind 和 listen。<strong>所以，bind 和 listen 是在 Master 进程中完成的。</strong></p>
<h3 id="1-2-Master-进程的主循环"><a href="#1-2-Master-进程的主循环" class="headerlink" title="1.2 Master 进程的主循环"></a>1.2 Master 进程的主循环</h3><p>在 ngx_master_process_cycle 中主要完成两件事。</p>
<ul>
<li>启动 Worker 进程</li>
<li>将 Master 进程推入事件循环</li>
</ul>
<p>在创建 Worker 进程的时候，是通过 fork 系统调用让 Worker 进程完全复制自己的资源，包括 listen 状态的 socket 句柄。</p>
<p><img src="/img/wiki-nginx-network/3.jpg"></p>
<p>我们接下来看详细的代码。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/os/unix/ngx_process_cycle.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ngx_master_process_cycle</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle)</span></span><br><span class="line">&#123;</span><br><span class="line"> ......</span><br><span class="line"> ngx_start_worker_processes(cycle, ccf-&gt;worker_processes,</span><br><span class="line">          NGX_PROCESS_RESPAWN);</span><br><span class="line"> <span class="comment">//进入主循环,等待接收各种信号</span></span><br><span class="line"> <span class="keyword">for</span> ( ;; ) &#123;</span><br><span class="line">  <span class="comment">//ngx_quit</span></span><br><span class="line">  <span class="comment">//ngx_reconfigure</span></span><br><span class="line">  <span class="comment">//ngx_restart</span></span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主进程在配置中读取到了 Worker 进程的数量 <code>ccf-&gt;worker_processes</code>。通过 ngx_start_worker_processes 来启动指定数量的 Worker。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:src/os/unix/ngx_process_cycle.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ngx_start_worker_processes</span><span class="params">(...)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  ngx_spawn_process(cycle, ngx_worker_process_cycle,</span><br><span class="line">        (<span class="type">void</span> *) (<span class="type">intptr_t</span>) i, <span class="string">&quot;worker process&quot;</span>, type);</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中值得注意的是，在调用 ngx_spawn_process 时的几个参数</p>
<ul>
<li>cycle：nginx 的核心数据结构</li>
<li>ngx_worker_process_cycle：worker 进程的入口函数</li>
<li>i: 当前 worker 的序号</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/os/unix/ngx_process.c</span></span><br><span class="line"><span class="type">ngx_pid_t</span> <span class="title function_">ngx_spawn_process</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle, ngx_spawn_proc_pt proc,...)</span></span><br><span class="line">&#123;</span><br><span class="line"> pid = fork();</span><br><span class="line"> <span class="keyword">switch</span> (pid) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">-1</span>: <span class="comment">//出错了</span></span><br><span class="line">   ... </span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//子进程创建成功</span></span><br><span class="line">   ngx_parent = ngx_pid;</span><br><span class="line">   ngx_pid = ngx_getpid();</span><br><span class="line">   proc(cycle, data);</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ngx_spawn_process 中调用 fork 来创建进程，创建成功后 Worker 进程就将进入 ngx_worker_process_cycle 来进行处理了。</p>
<p><strong>总结：</strong> 在网络上，master 进程其实只是 listen 了一下。listen 过后的 socket 存到 cycle-&gt;listening 这里了。剩下的网络操作都是在 Worker 中完成的。</p>
<h2 id="二、Worker-进程处理"><a href="#二、Worker-进程处理" class="headerlink" title="二、Worker 进程处理"></a>二、Worker 进程处理</h2><p>在上面小节中看到，Master 进程关于网络其实做的事情不多，只是 bind 和 listen 了一下。epoll 相关的函数调用一个也没见着，更别说 accept 接收连接，以及 read 、 write 函数处理了。那这些细节一定都是在 Worker 进程中完成的。</p>
<p>事实的确如此，epoll_create、epoll_ctl、epoll_wait 都是在 Worker 进程中执行的。</p>
<p><img src="/img/wiki-nginx-network/4.jpg"></p>
<p>在 Worker 进程中，创建了一个 epoll 内核对象，通过 epoll_ctl 将其想监听的事件注册上去，然后调用 epoll_wait 进入事件循环。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/os/unix/ngx_process_cycle.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ngx_worker_process_cycle</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//2.2 Worker进程初始化编译进来的各个模块</span></span><br><span class="line"> ngx_worker_process_init(cycle, worker);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//进入事件循环</span></span><br><span class="line"> <span class="keyword">for</span> ( ;; ) &#123;</span><br><span class="line">  <span class="comment">//2.3 进入 epollwait</span></span><br><span class="line">  ngx_process_events_and_timers(cycle);</span><br><span class="line">  ......</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们分别来细看。</p>
<h3 id="2-1-Nginx-的-网络相关-module"><a href="#2-1-Nginx-的-网络相关-module" class="headerlink" title="2.1 Nginx 的 网络相关 module"></a>2.1 Nginx 的 网络相关 module</h3><p>撇开 Worker 的工作流程不提，咱们先来了解一个背景知识 - Nginx module。</p>
<p>Nginx 采用的是一种模块化的架构，它的模块包括核心模块、标准HTTP模块、可选HTTP模块、邮件服务模块和第三方模块等几大类。每一个模块都以一个 module 的形式存在，都对应一个 ngx_module_s 结构体。通过这种方式来实现软件可拔插，是一种非常优秀的软件架构。</p>
<p><img src="/img/wiki-nginx-network/5.jpg"></p>
<p>每个 module 根据自己的需求来实现各种 init_xxx, exit_xxx 方法来供 Nginx 在合适的时机调用。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/core/ngx_module.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_module_s</span> &#123;</span></span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="type">ngx_uint_t</span>            version;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span>                 *ctx;</span><br><span class="line"> <span class="type">ngx_command_t</span>        *commands;</span><br><span class="line"> <span class="type">ngx_uint_t</span>            type;</span><br><span class="line"></span><br><span class="line"> <span class="type">ngx_int_t</span>           (*init_master)(<span class="type">ngx_log_t</span> *<span class="built_in">log</span>);</span><br><span class="line"> <span class="type">ngx_int_t</span>           (*init_module)(<span class="type">ngx_cycle_t</span> *cycle);</span><br><span class="line"> <span class="type">ngx_int_t</span>           (*init_process)(<span class="type">ngx_cycle_t</span> *cycle);</span><br><span class="line"> <span class="type">ngx_int_t</span>           (*init_thread)(<span class="type">ngx_cycle_t</span> *cycle);</span><br><span class="line"> <span class="type">void</span>                (*exit_thread)(<span class="type">ngx_cycle_t</span> *cycle);</span><br><span class="line"> <span class="type">void</span>                (*exit_process)(<span class="type">ngx_cycle_t</span> *cycle);</span><br><span class="line"> <span class="type">void</span>                (*exit_master)(<span class="type">ngx_cycle_t</span> *cycle);</span><br><span class="line"></span><br><span class="line"> ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中和网络相关的 module 有 ngx_events_module 、ngx_event_core_module 和具体的网络底层模块 ngx_epoll_module、ngx_kqueue_module等。</p>
<p>对于 ngx_epoll_module 来说，它在其上下文 ngx_epoll_module_ctx 中定义了各种 actions 方法（添加事件、删除事件、添加连接等）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:src/event/ngx_event.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> <span class="type">ngx_str_t</span>              *name;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span>                 *(*create_conf)(<span class="type">ngx_cycle_t</span> *cycle);</span><br><span class="line"> <span class="type">char</span>                 *(*init_conf)(<span class="type">ngx_cycle_t</span> *cycle, <span class="type">void</span> *conf);</span><br><span class="line"></span><br><span class="line"> <span class="type">ngx_event_actions_t</span>     actions;</span><br><span class="line">&#125; <span class="type">ngx_event_module_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:src/event/modules/ngx_epoll_module.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">ngx_event_module_t</span>  ngx_epoll_module_ctx = &#123;</span><br><span class="line"> &amp;epoll_name,</span><br><span class="line"> ngx_epoll_create_conf,               <span class="comment">/* create configuration */</span></span><br><span class="line"> ngx_epoll_init_conf,                 <span class="comment">/* init configuration */</span></span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line">  ngx_epoll_add_event,             <span class="comment">/* add an event */</span></span><br><span class="line">  ngx_epoll_del_event,             <span class="comment">/* delete an event */</span></span><br><span class="line">  ngx_epoll_add_event,             <span class="comment">/* enable an event */</span></span><br><span class="line">  ngx_epoll_del_event,             <span class="comment">/* disable an event */</span></span><br><span class="line">  ngx_epoll_add_connection,        <span class="comment">/* add an connection */</span></span><br><span class="line">  ngx_epoll_del_connection,        <span class="comment">/* delete an connection */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_HAVE_EVENTFD)</span></span><br><span class="line">  ngx_epoll_notify,                <span class="comment">/* trigger a notify */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="literal">NULL</span>,                            <span class="comment">/* trigger a notify */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ngx_epoll_process_events,        <span class="comment">/* process the events */</span></span><br><span class="line">  ngx_epoll_init,                  <span class="comment">/* init the events */</span></span><br><span class="line">  ngx_epoll_done,                  <span class="comment">/* done the events */</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中有一个 init 方法是 ngx_epoll_init，在这个 init 中会进行 epoll 对象的创建，以及 ngx_event_actions 方法的设置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:src/event/modules/ngx_epoll_module.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">ngx_int_t</span></span><br><span class="line"><span class="title function_">ngx_epoll_init</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle, <span class="type">ngx_msec_t</span> timer)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//创建一个 epoll 句柄</span></span><br><span class="line"> ep = epoll_create(cycle-&gt;connection_n / <span class="number">2</span>);</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> ngx_event_actions = ngx_epoll_module_ctx.actions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-Worker-进程初始化各个模块"><a href="#2-2-Worker-进程初始化各个模块" class="headerlink" title="2.2 Worker 进程初始化各个模块"></a>2.2 Worker 进程初始化各个模块</h3><p>Worker 进程初始化的时候，在 ngx_worker_process_init 中读取配置信息进行一些设置，然后调用所有模块的 init_process 方法。</p>
<p><img src="/img/wiki-nginx-network/6.jpg"></p>
<p>来看详细代码。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/os/unix/ngx_process_cycle.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ngx_worker_process_init</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle, <span class="type">ngx_int_t</span> worker)</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取配置</span></span><br><span class="line"> ccf = (<span class="type">ngx_core_conf_t</span> *) ngx_get_conf(cycle-&gt;conf_ctx, ngx_core_module);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//设置优先级</span></span><br><span class="line"> setpriority(PRIO_PROCESS, <span class="number">0</span>, ccf-&gt;priority)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//设置文件描述符限制</span></span><br><span class="line"> setrlimit(RLIMIT_NOFILE, &amp;rlmt)</span><br><span class="line"> setrlimit(RLIMIT_CORE, &amp;rlmt)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//group 和 uid 设置</span></span><br><span class="line"> initgroups(ccf-&gt;username, ccf-&gt;group)</span><br><span class="line"> setuid(ccf-&gt;user)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//CPU亲和性</span></span><br><span class="line"> cpu_affinity = ngx_get_cpu_affinity(worker)</span><br><span class="line"> <span class="keyword">if</span> (cpu_affinity) &#123;</span><br><span class="line">  ngx_setaffinity(cpu_affinity, cycle-&gt;<span class="built_in">log</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="comment">//调用各个模块的init_process进行模块初始化</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; cycle-&gt;modules[i]; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (cycle-&gt;modules[i]-&gt;init_process) &#123;</span><br><span class="line">   <span class="keyword">if</span> (cycle-&gt;modules[i]-&gt;init_process(cycle) == NGX_ERROR) &#123;</span><br><span class="line">    <span class="comment">/* fatal */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我们说过 ngx_event_core_module ，它的 init_process 方法是 ngx_event_process_init。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event.c</span></span><br><span class="line"><span class="type">ngx_module_t</span>  ngx_event_core_module = &#123;</span><br><span class="line"> ...</span><br><span class="line"> ngx_event_process_init,                <span class="comment">/* init process */</span></span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 ngx_event_core_module 的 ngx_event_process_init 中，我们将看到 <strong>Worker 进程使用 epoll_create 来创建 epoll 对象，使用epoll_ctl 来监听 listen socket 上的连接请求</strong>。</p>
<p><img src="/img/wiki-nginx-network/7.jpg"></p>
<p>来详细看 ngx_event_process_init 的代码。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">ngx_int_t</span> <span class="title function_">ngx_event_process_init</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//调用模块的init，创建 epoll 对象</span></span><br><span class="line"> <span class="keyword">for</span> (m = <span class="number">0</span>; cycle-&gt;modules[m]; m++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (cycle-&gt;modules[m]-&gt;type != NGX_EVENT_MODULE) &#123;</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  module-&gt;actions.init(cycle, ngx_timer_resolution)</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取自己监听的sokcet，将它们都添加到 epoll 中</span></span><br><span class="line"> <span class="type">ngx_event_t</span>         *rev</span><br><span class="line"> ls = cycle-&gt;listening.elts;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cycle-&gt;listening.nelts; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取一个 ngx_connection_t</span></span><br><span class="line">  c = ngx_get_connection(ls[i].fd, cycle-&gt;<span class="built_in">log</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置回调函数为 ngx_event_accept</span></span><br><span class="line">  rev-&gt;handler = ngx_event_accept </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ngx_add_event(rev, NGX_READ_EVENT, <span class="number">0</span>) == NGX_ERROR) &#123;</span><br><span class="line">   <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 ngx_add_event 注册的 READ 事件的处理函数。ngx_add_event 就是一个抽象，对于 epoll 来说就是对 epoll_ctl 的封装而已。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_add_event        ngx_event_actions.add</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//file: src/event/modules/ngx_epoll_module.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">ngx_int_t</span> <span class="title function_">ngx_epoll_add_event</span><span class="params">(...)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (epoll_ctl(ep, op, c-&gt;fd, &amp;ee) == <span class="number">-1</span>) &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TODO: epoll_create 还没解决呢。</p>
<h3 id="2-3-进入-epollwait"><a href="#2-3-进入-epollwait" class="headerlink" title="2.3 进入 epollwait"></a>2.3 进入 epollwait</h3><p>在 ngx_worker_process_init 中， epoll_create 和 epoll_ctl 都已经完成了。接下来就是进入事件循环，执行 epoll_wait 来处理。</p>
<p><img src="/img/wiki-nginx-network/8.jpg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ngx_process_events_and_timers</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle)</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="comment">// 防accept惊群锁</span></span><br><span class="line"> <span class="keyword">if</span> (ngx_use_accept_mutex) &#123;</span><br><span class="line">  <span class="comment">//尝试获取锁，获取失败直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) &#123;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取锁成功，则设置 NGX_POST_EVENTS 标记。</span></span><br><span class="line">  <span class="keyword">if</span> (ngx_accept_mutex_held) &#123;</span><br><span class="line">   flags |= NGX_POST_EVENTS;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//处理各种事件</span></span><br><span class="line"> (<span class="type">void</span>) ngx_process_events(cycle, timer, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ngx_process_events_and_timers 开头处，判断是否使用 accpet_mutext 锁。这是一个防止惊群的解决办法。如果使用的话，先调用 ngx_trylock_accept_mutex 获取锁，获取失败则直接返回，过段时间再来尝试。获取成功是则设置 NGX_POST_EVENTS 的标志位。</p>
<p>接下来调用 ngx_process_events 来处理各种网络和 timer 事件。对于 epoll 来说，这个函数就是对 epoll_wait 的封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_process_events   ngx_event_actions.process_events</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/event/modules/ngx_epoll_module.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">ngx_int_t</span> <span class="title function_">ngx_epoll_process_events</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle, ...)</span></span><br><span class="line">&#123;</span><br><span class="line"> events = epoll_wait(ep, event_list, (<span class="type">int</span>) nevents, timer);</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; events; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flags &amp; NGX_POST_EVENTS) &#123;</span><br><span class="line">   ...</span><br><span class="line">   ngx_post_event(rev, <span class="built_in">queue</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="comment">//调用回调函数</span></span><br><span class="line">   rev-&gt;handler(rev);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，在 ngx_epoll_process_events 是调用 epoll_wait 等待各种事件的发生。如果没有 NGX_POST_EVENTS 标志，则直接回调 rev-&gt;handler 进行处理。使用了 accept_mutex 锁的话，先把这个事件保存起来，等后面合适的时机再去 accpet。</p>
<p>简单对本节内容汇总一下。在 Master 进程中只是做了 socket 的 bind 和 listen。 而在 Worker 进程中所做的事情比较多，创建了 epoll，使用 epoll_ctl 将 listen 状态的 socket 的事件监控起来。最后调用 epoll_wait 进入了事件循环，开始处理各种网络和 timer 事件。 本节流程总结如图。</p>
<p><img src="/img/wiki-nginx-network/9.jpg"></p>
<h2 id="三、用户连接来啦！"><a href="#三、用户连接来啦！" class="headerlink" title="三、用户连接来啦！"></a>三、用户连接来啦！</h2><p>现在假设用户的连接请求已经到了，这时候 epoll_wait 返回后会执行其对应的 handler 函数 ngx_add_event。</p>
<p><img src="/img/wiki-nginx-network/10.jpg"></p>
<p>在该回调函数中被执行到的时候，表示 listen 状态的 socket 上面有连接到了。所以这个函数主要做了三件事。  </p>
<ul>
<li>1.调用 accept 获取用户连接</li>
<li>2.获取 connection 对象，其回调函数为 ngx_http_init_connection</li>
<li>3.将新连接 socket 通过 epoll_ctl 添加到 epoll 中进行管理</li>
</ul>
<p>我们来看 ngx_event_accept 详细代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event_accept.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ngx_event_accept</span><span class="params">(<span class="type">ngx_event_t</span> *ev)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">//接收建立好的连接</span></span><br><span class="line">  s = accept(lc-&gt;fd, &amp;sa.sockaddr, &amp;socklen);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> s &#123;</span><br><span class="line">   <span class="comment">//3.1 获取 connection</span></span><br><span class="line">   c = ngx_get_connection(s, ev-&gt;<span class="built_in">log</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.2 添加新连接</span></span><br><span class="line">   <span class="keyword">if</span> (ngx_add_conn(c) == NGX_ERROR) &#123;</span><br><span class="line">    ngx_close_accepted_connection(c);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; </span><br><span class="line"> &#125; <span class="keyword">while</span> (ev-&gt;available);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>listen socket 上的读事件发生的时候，就意味着有用户连接就绪了。所以可以直接通过 accept 将其取出来。取出连接以后，再获取一个空闲的 connection对象，通过 ngx_add_conn 将其添加到 epoll 中进行管理。</p>
<h3 id="3-1-获取-connection"><a href="#3-1-获取-connection" class="headerlink" title="3.1 获取 connection"></a>3.1 获取 connection</h3><p>我们说一下 ngx_get_connection，这个函数本身倒是没有啥可说的。就是从 ngx_cycle 的 free_connections 中获取一个 connection 出来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/core/ngx_connection.c</span></span><br><span class="line"><span class="type">ngx_connection_t</span> *<span class="title function_">ngx_get_connection</span><span class="params">(<span class="type">ngx_socket_t</span> s, <span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> c = ngx_cycle-&gt;free_connections;</span><br><span class="line"> c-&gt;read = rev;</span><br><span class="line"> c-&gt;write = wev;</span><br><span class="line"> c-&gt;fd = s;</span><br><span class="line"> c-&gt;<span class="built_in">log</span> = <span class="built_in">log</span>;</span><br><span class="line"> <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得说的是 free_connections 中的连接，对于 HTTP 服务来说，会经过 ngx_http_init_connection 的初始化处理。它会设置该连接读写事件的回调函数 c-&gt;read-&gt;handler 和 c-&gt;write-&gt;handler。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/http/ngx_http_request.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ngx_http_init_connection</span><span class="params">(<span class="type">ngx_connection_t</span> *c)</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> rev = c-&gt;read;</span><br><span class="line"> rev-&gt;handler = ngx_http_wait_request_handler;</span><br><span class="line"> c-&gt;write-&gt;handler = ngx_http_empty_handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-添加新连接"><a href="#3-2-添加新连接" class="headerlink" title="3.2 添加新连接"></a>3.2 添加新连接</h3><p>我们再来看 ngx_add_conn，对于 epoll module 来说，它就是 ngx_epoll_add_connection 这个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_add_conn         ngx_event_actions.add_conn</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//file: src/event/modules/ngx_epoll_module.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">ngx_int_t</span></span><br><span class="line"><span class="title function_">ngx_epoll_add_connection</span><span class="params">(<span class="type">ngx_connection_t</span> *c)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>  <span class="title">ee</span>;</span></span><br><span class="line"> ee.events = EPOLLIN|EPOLLOUT|EPOLLET|EPOLLRDHUP;</span><br><span class="line"> ee.data.ptr = (<span class="type">void</span> *) ((<span class="type">uintptr_t</span>) c | c-&gt;read-&gt;instance);</span><br><span class="line"></span><br><span class="line"> epoll_ctl(ep, EPOLL_CTL_ADD, c-&gt;fd, &amp;ee)</span><br><span class="line"> c-&gt;read-&gt;active = <span class="number">1</span>;</span><br><span class="line"> c-&gt;write-&gt;active = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见这只是 epoll_ctl 的一个封装而已。这里再补充说一下，如果这个客户端连接 socket 上有数据到达的时候，就会进入到上面 3.1 节中注册的 ngx_http_wait_request_handler 函数进行处理。后面就是 HTTP 的处理逻辑了。</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>Nginx 的 Master 中做的网络相关动作不多，仅仅只是创建了 socket、然后 bind 并 listen 了一下。接着就是用自己 fork 出来多个 Worker 进程来。由于每个进程都一样，所以每个 Worker 都有 Master 创建出来的 listen 状态的 socket 句柄。</p>
<p><img src="/img/wiki-nginx-network/11.jpg"></p>
<p>Worker 进程处理的网络相关工作就比较多了。epoll_create、epoll_ctl、epoll_wait 都是在 Worker 进程中执行的，也包括用户连接上的数据 read、处理 和 write。  </p>
<p><img src="/img/wiki-nginx-network/12.jpg"></p>
<ul>
<li>1.先是使用 epoll_create 创建一个 epoll 对象出来</li>
<li>2.设置回调为 ngx_event_accept</li>
<li>3.通过 epoll_ctl 将所有 listen 状态的 socket 的事件都管理起来</li>
<li>4.执行 epoll_wait 等待 listen socket 上的连接到来</li>
<li>5.新连接到来是 epoll_wait 返回，进入 ngx_event_accept 回调</li>
<li>6.ngx_event_accept 回调中将新连接也添加到 epoll 中进行管理（其回调为ngx_http_init_connection）</li>
<li>7.继续进入 epoll_wait 等待事件</li>
<li>8.用户数据请求到达时进入 http 回调函数进行处理</li>
</ul>
<p>讲到这里，你可以觉得咱们已经讨论完了。实际上有一个点我们还没有考虑到。我们上面讨论的流程是一个 Worker 在工作的情况。那么在多 Worker 的情况下，Nginx 的全貌咱们还没展开说过。通过上文我们可以看到以下几个细节：</p>
<ul>
<li>1.每个 Worker 都会有一个属于自己的 epoll 对象</li>
<li>2.每个 Worker 会关注所有的 listen 状态上的新连接事件</li>
<li>3.对于用户连接，只有一个 Worker 会处理，其它 Worker 不会持有该用户连接的 socket。</li>
</ul>
<p>根据这三条结论，我们再画一个 Nginx 的全貌图。</p>
<p><img src="/img/wiki-nginx-network/13.jpg"></p>
<p>好了，今天关于 Nginx 网络原理的分享就到此结束。希望通过这个优秀的软件能给你的工作带去一些启发和思考，助力你的工作提升。能阅读到这里的同学们都是好样的，晚餐回去都给自己加个鸡腿！  </p>
<p>最后学学极客时间，留一道思考题。</p>
<p><strong>思考题：</strong>“上面这个图中每个 Worker 里的 epoll 对象会监听同一批 listen 状态的 socket，那么当有用户连接到来的时候，Nginx 和 Linux 是如何保证没有惊群问题的呢（只有一个 Worker 来响应该请求）？欢迎你把你的思考留在评论区。”</p>
<article class="message message-immersive is-primary">
<div class="message-body">
<i class="fas fa-globe-asia mr-2"></i>本文来自
<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/AX6Fval8RwkgzptdjlU5kg">开发内功修炼</a>.
</div>
</article>
    </div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Linux%E7%BD%91%E7%BB%9C/">Linux网络</a></div><!--!--><div><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6757924689439593" crossOrigin="anonymous"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6757924689439593" data-ad-slot="2352785969"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/pages/wiki-cache/"><span class="level-item">一文了解缓存</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div style="width:100%"><script src="https://giscus.app/client.js" data-repo="thetechstack/thetechstack.github.io" data-repo-id="R_kgDOG6Ti1Q" data-category="Announcements" data-category-id="DIC_kwDOG6Ti1c4COQtm" data-mapping="pathname" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="zh-CN" crossOrigin="anonymous" async></script></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一、-Nginx-Master-进程初始化"><span class="level-left"><span class="level-item">1</span><span class="level-item">一、 Nginx Master 进程初始化</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-Nginx-的服务端口监听"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">1.1 Nginx 的服务端口监听</span></span></a></li><li><a class="level is-mobile" href="#1-2-Master-进程的主循环"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">1.2 Master 进程的主循环</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二、Worker-进程处理"><span class="level-left"><span class="level-item">2</span><span class="level-item">二、Worker 进程处理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-Nginx-的-网络相关-module"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">2.1 Nginx 的 网络相关 module</span></span></a></li><li><a class="level is-mobile" href="#2-2-Worker-进程初始化各个模块"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">2.2 Worker 进程初始化各个模块</span></span></a></li><li><a class="level is-mobile" href="#2-3-进入-epollwait"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">2.3 进入 epollwait</span></span></a></li></ul></li><li><a class="level is-mobile" href="#三、用户连接来啦！"><span class="level-left"><span class="level-item">3</span><span class="level-item">三、用户连接来啦！</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-获取-connection"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">3.1 获取 connection</span></span></a></li><li><a class="level is-mobile" href="#3-2-添加新连接"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">3.2 添加新连接</span></span></a></li></ul></li><li><a class="level is-mobile" href="#四、总结"><span class="level-left"><span class="level-item">4</span><span class="level-item">四、总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/CPython/"><span class="tag">CPython</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Feed%E6%9C%8D%E5%8A%A1/"><span class="tag">Feed服务</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Knative/"><span class="tag">Knative</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kubernetes/"><span class="tag">Kubernetes</span><span class="tag">25</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux%E7%BD%91%E7%BB%9C/"><span class="tag">Linux网络</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RPC/"><span class="tag">RPC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Serverless/"><span class="tag">Serverless</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Yarn/"><span class="tag">Yarn</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/"><span class="tag">分布式一致性</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9C%A8%E7%A6%BB%E7%BA%BF%E6%B7%B7%E9%83%A8/"><span class="tag">在离线混部</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="tag">大数据</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/"><span class="tag">时间序列</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%99%BA%E8%83%BD%E8%BF%90%E7%BB%B4/"><span class="tag">智能运维</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%93%E5%AD%98/"><span class="tag">缓存</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"><span class="tag">编译原理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96/"><span class="tag">网络虚拟化</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"><span class="tag">虚拟机</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"><span class="tag">语言特性</span><span class="tag">2</span></a></div></div></div></div></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg"></figure><p class="is-size-6 is-block">公众号：面向问题编程</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">72</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">19</p></a></div></div></nav></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3/"><span class="level-start"><span class="level-item">一文了解</span></span><span class="level-end"><span class="level-item tag">33</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5/"><span class="level-start"><span class="level-item">技术实践</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"><span class="level-start"><span class="level-item">技术架构</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BB%BC%E8%BF%B0/"><span class="level-start"><span class="level-item">综述</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%97%AE%E9%A2%98/"><span class="level-start"><span class="level-item">问题</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="面向问题编程" height="28"></a><p class="is-size-7"><span>&copy; 2022 面向问题编程</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lg-zoom@1.3.0/dist/lg-zoom.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>