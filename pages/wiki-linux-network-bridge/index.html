<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>一文了解 Linux 虚拟网络设备Bridge - 面向问题编程</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="面向问题编程"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="面向问题编程"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Linux Bridge（网桥）是用纯软件实现的虚拟交换机，有着和物理交换机相同的功能，例如二层交换，MAC地址学习等。因此我们可以把tun&amp;#x2F;tap，veth pair等设备绑定到网桥上，就像是把设备连接到物理交换机上一样。此外它和veth pair、tun&amp;#x2F;tap一样，也是一种虚拟网络设备，具有虚拟设备的所有特性，例如配置IP，MAC地址等"><meta property="og:type" content="blog"><meta property="og:title" content="一文了解 Linux 虚拟网络设备Bridge"><meta property="og:url" content="https://www.heapoverflow.cn/pages/wiki-linux-network-bridge/"><meta property="og:site_name" content="面向问题编程"><meta property="og:description" content="Linux Bridge（网桥）是用纯软件实现的虚拟交换机，有着和物理交换机相同的功能，例如二层交换，MAC地址学习等。因此我们可以把tun&amp;#x2F;tap，veth pair等设备绑定到网桥上，就像是把设备连接到物理交换机上一样。此外它和veth pair、tun&amp;#x2F;tap一样，也是一种虚拟网络设备，具有虚拟设备的所有特性，例如配置IP，MAC地址等"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.heapoverflow.cn/img/wiki-linux-network-bridge/2.jpg"><meta property="article:published_time" content="2022-03-27T09:05:57.773Z"><meta property="article:modified_time" content="2022-04-02T23:22:00.710Z"><meta property="article:author" content="面向问题编程"><meta property="article:tag" content="Linux网络"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/wiki-linux-network-bridge/2.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.heapoverflow.cn/pages/wiki-linux-network-bridge/"},"headline":"一文了解 Linux 虚拟网络设备Bridge","image":["https://www.heapoverflow.cn/img/wiki-linux-network-bridge/2.jpg"],"datePublished":"2022-03-27T09:05:57.773Z","dateModified":"2022-04-02T23:22:00.710Z","author":{"@type":"Person","name":"面向问题编程"},"publisher":{"@type":"Organization","name":"面向问题编程","logo":{"@type":"ImageObject","url":"https://www.heapoverflow.cn/img/logo.svg"}},"description":"Linux Bridge（网桥）是用纯软件实现的虚拟交换机，有着和物理交换机相同的功能，例如二层交换，MAC地址学习等。因此我们可以把tun&#x2F;tap，veth pair等设备绑定到网桥上，就像是把设备连接到物理交换机上一样。此外它和veth pair、tun&#x2F;tap一样，也是一种虚拟网络设备，具有虚拟设备的所有特性，例如配置IP，MAC地址等"}</script><link rel="canonical" href="https://www.heapoverflow.cn/pages/wiki-linux-network-bridge/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-ETGL163DQH" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-ETGL163DQH');</script><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-6757924689439593" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="面向问题编程" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories/%E9%97%AE%E9%A2%98/">问题</a><a class="navbar-item" href="/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/">技术架构</a><a class="navbar-item" href="/categories/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3/">一文了解</a></div><div class="navbar-end"><a class="navbar-item" rel="noopener" title="分类" href="/categories">分类</a><a class="navbar-item" rel="noopener" title="标签" href="/tags">标签</a><a class="navbar-item" rel="noopener" title="归档" href="/archives">归档</a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/wiki-linux-network-bridge/2.jpg" alt="一文了解 Linux 虚拟网络设备Bridge"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-27T09:05:57.773Z" title="2022/3/27 下午5:05:57">2022-03-27</time>发表</span><span class="level-item"><time dateTime="2022-04-02T23:22:00.710Z" title="2022/4/3 上午7:22:00">2022-04-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3/">一文了解</a></span><span class="level-item">31 分钟读完 (大约4629个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">一文了解 Linux 虚拟网络设备Bridge</h1><div class="content"><article class="message is-primary" style="font-size:inherit">
<div class="message-body">
Linux Bridge（网桥）是用纯软件实现的虚拟交换机，有着和物理交换机相同的功能，例如二层交换，MAC地址学习等。因此我们可以把tun/tap，veth pair等设备绑定到网桥上，就像是把设备连接到物理交换机上一样。此外它和veth pair、tun/tap一样，也是一种虚拟网络设备，具有虚拟设备的所有特性，例如配置IP，MAC地址等
</div>
</article>

<span id="more"></span>


<p>大家好，我是飞哥！</p>
<p>Linux 中的 veth 是一对儿能互相连接、互相通信的虚拟网卡。通过使用它，我们可以让 Docker 容器和母机通信，或者是在两个 Docker 容器中进行交流。参见<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247486424&idx=1&sn=d66fe4ebf1cd9e5079606f71a0169697&scene=21#wechat_redirect">《轻松理解 Docker 网络虚拟化基础之 veth 设备！》</a>。</p>
<p><img src="/img/wiki-linux-network-bridge/0.jpg"></p>
<p>不过在实际中，我们会想在一台物理机上我们虚拟出来几个、甚至几十个容器，以求得充分压榨物理机的硬件资源。但这样带来的问题是大量的容器之间的网络互联。很明显上面简单的 veth 互联方案是没有办法直接工作的，我们该怎么办？？？  </p>
<p>回头想一下，在物理机的网络环境中，多台不同的物理机之间是如何连接一起互相通信的呢？没错，那就是以太网交换机。同一网络内的多台物理机通过交换机连在一起，然后它们就可以相互通信了。</p>
<p><img src="/img/wiki-linux-network-bridge/1.jpg"></p>
<p>在我们的网络虚拟化环境里，和物理网络中的交换机一样，也需要这样的一个软件实现的设备。它需要有很多个虚拟端口，能把更多的虚拟网卡连接在一起，通过自己的转发功能让这些虚拟网卡之间可以通信。在 Linux 下这个软件实现交换机的技术就叫做 bridge（再强调下，这是纯软件实现的）。  </p>
<p><img src="/img/wiki-linux-network-bridge/2.jpg"></p>
<p>各个 Docker 容器都通过 veth 连接到 bridge 上，bridge 负责在不同的“端口”之间转发数据包。这样各个 Docker 之间就可以互相通信了！  </p>
<p>今天我们来展开聊聊 bridge 的详细工作过程。</p>
<h2 id="一、如何使用-bridge"><a href="#一、如何使用-bridge" class="headerlink" title="一、如何使用 bridge"></a>一、如何使用 bridge</h2><p>在分析它的工作原理之前，很有必要先来看一看网桥是如何使用的。</p>
<p>为了方便大家理解，接下来我们通过动手实践的方式，在一台 Linux 上创建一个小型的虚拟网络出来，并让它们之间互相通信。</p>
<h3 id="1-1-创建两个不同的网络"><a href="#1-1-创建两个不同的网络" class="headerlink" title="1.1 创建两个不同的网络"></a>1.1 创建两个不同的网络</h3><p>Bridge 是用来连接两个不同的虚拟网络的，所以在准备实验 bridge 之前我们得先需要用 net namespace 构建出两个不同的网络空间来。</p>
<p><img src="/img/wiki-linux-network-bridge/3.jpg"></p>
<p>具体的创建过程如下。我们通过 ip netns 命令创建 net namespace。首先创建一个 net1：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ip netns add net1  </span><br></pre></td></tr></table></figure>


<p>接下来创建一对儿 veth 出来，设备名分别是 veth1 和 veth1_p。并把其中的一头 veth1 放到这个新的 netns 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ip link add veth1 type veth peer name veth1_p  </span><br><span class="line"># ip link set veth1 netns net1  </span><br></pre></td></tr></table></figure>


<p>因为我们打算是用这个 veth1 来通信，所以需要为其配置上 ip，并把它启动起来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ip netns exec net1 ip addr add 192.168.0.101/24 dev veth1  </span><br><span class="line"># ip netns exec net1 ip link set veth1 up  </span><br></pre></td></tr></table></figure>


<p>查看一下，上述的配置是否成功。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ip netns exec net1 ip link list  </span><br><span class="line"># ip netns exec net1 ifconfig  </span><br></pre></td></tr></table></figure>


<p>重复上述步骤，在创建一个新的 netns出来，命名分别为。</p>
<ul>
<li>netns: net2</li>
<li>veth pair: veth2, veth2_p</li>
<li>ip: 192.168.0.102</li>
</ul>
<p>好了，这样我们就在一台 Linux 就创建出来了两个虚拟的网络环境。</p>
<h3 id="1-2-把两个网络连接到一起"><a href="#1-2-把两个网络连接到一起" class="headerlink" title="1.2 把两个网络连接到一起"></a>1.2 把两个网络连接到一起</h3><p>在上一个步骤中，我们只是创建出来了两个独立的网络环境而已。这个时候这两个环境之间还不能互相通信。我们需要创建一个虚拟交换机 - bridge， 来把这两个网络环境连起来。  </p>
<p><img src="/img/wiki-linux-network-bridge/4.jpg"></p>
<p>创建过程如下。创建一个 bridge 设备, 把刚刚创建的两对儿 veth 中剩下的两头“插”到 bridge 上来。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># brctl addbr br0  </span><br><span class="line"># ip link set dev veth1_p master br0  </span><br><span class="line"># ip link set dev veth2_p master br0  </span><br><span class="line"># ip addr add 192.168.0.100/24 dev br0  </span><br></pre></td></tr></table></figure>


<p>再为 bridge 配置上 IP，并把 bridge 以及插在其上的 veth 启动起来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ip link set veth1_p up  </span><br><span class="line"># ip link set veth2_p up  </span><br><span class="line"># ip link set br0 up  </span><br></pre></td></tr></table></figure>


<p>查看一下当前 bridge 的状态，确认刚刚的操作是成功了的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># brctl show  </span><br><span class="line">bridge name     bridge id               STP enabled     interfaces  </span><br><span class="line">br0             8000.4e931ecf02b1       no              veth1_p  </span><br><span class="line">                                                        veth2_p  </span><br></pre></td></tr></table></figure>


<h3 id="1-3-网络连通测试"><a href="#1-3-网络连通测试" class="headerlink" title="1.3 网络连通测试"></a>1.3 网络连通测试</h3><p>激动人心的时刻就要到了，我们在 net1 里（通过指定 ip netns exec net1 以及 -I veth1），ping 一下 net2 里的 IP（192.168.0.102）试试。</p>
<p><img src="/img/wiki-linux-network-bridge/5.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ip netns exec net1 ping 192.168.0.102 -I veth1</span><br><span class="line">PING 192.168.0.102 (192.168.0.102) from 192.168.0.101 veth1: 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.0.102: icmp_seq=1 ttl=64 time=0.037 ms</span><br><span class="line">64 bytes from 192.168.0.102: icmp_seq=2 ttl=64 time=0.008 ms</span><br><span class="line">64 bytes from 192.168.0.102: icmp_seq=3 ttl=64 time=0.005 ms</span><br></pre></td></tr></table></figure>

<p>哇塞，通了通了！！</p>
<p>这样，我们就在一台 Linux 上虚拟出了 net1 和 net2 两个不同的网络环境。我们还可以按照这种方式创建更多的网络，都可以通过一个 bridge 连接到一起。这就是 Docker 中网络系统工作的基本原理。</p>
<h2 id="二、Bridge-是如何创建出来的"><a href="#二、Bridge-是如何创建出来的" class="headerlink" title="二、Bridge 是如何创建出来的"></a>二、Bridge 是如何创建出来的</h2><p>在内核中，bridge 是由两个相邻存储的内核对象来表示的。</p>
<p><img src="/img/wiki-linux-network-bridge/6.jpg"></p>
<p>我们先看下它是如何被创建出来的。内核中创建 bridge 的关键代码在 br_add_bridge 这个函数里。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:net/bridge/br_if.c  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">br_add_bridge</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="type">char</span> *name)</span>  </span><br><span class="line">&#123;  </span><br><span class="line"> <span class="comment">//申请网桥设备，并用 br_dev_setup 来启动它  </span></span><br><span class="line"> dev = alloc_netdev(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> net_bridge), name,  </span><br><span class="line">      br_dev_setup);  </span><br><span class="line">  </span><br><span class="line"> dev_net_set(dev, net);  </span><br><span class="line"> dev-&gt;rtnl_link_ops = &amp;br_link_ops;  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">//注册网桥设备  </span></span><br><span class="line"> res = register_netdev(dev);  </span><br><span class="line"> <span class="keyword">if</span> (res)  </span><br><span class="line">  free_netdev(dev);  </span><br><span class="line"> <span class="keyword">return</span> res;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<p>上述代码中注册网桥的关键代码是 alloc_netdev 这一行。在这个函数里，将申请网桥的内核对象 net_device。在这个函数调用里要注意两点。</p>
<ul>
<li>1.第一个参数传入了 struct net_bridge 的大小</li>
<li>2.第三个参数传入的 br_dev_setup 是一个函数。</li>
</ul>
<p>带着这两点注意事项，我们进入到 alloc_netdev 的实现中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: include/linux/netdevice.h  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> alloc_netdev(sizeof_priv, name, setup) \  </span></span><br><span class="line"> alloc_netdev_mqs(sizeof_priv, name, setup, <span class="number">1</span>, <span class="number">1</span>)  </span><br></pre></td></tr></table></figure>


<p>好吧，竟然是个宏。那就得看 alloc_netdev_mqs 了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/core/dev.c  </span></span><br><span class="line"><span class="keyword">struct</span> net_device *<span class="title function_">alloc_netdev_mqs</span><span class="params">(<span class="type">int</span> sizeof_priv, ...，<span class="type">void</span> (*setup)(<span class="keyword">struct</span> net_device *))</span>  </span><br><span class="line">&#123;  </span><br><span class="line"> <span class="comment">//申请网桥设备  </span></span><br><span class="line"> alloc_size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> net_device);  </span><br><span class="line"> <span class="keyword">if</span> (sizeof_priv) &#123;  </span><br><span class="line">  alloc_size = ALIGN(alloc_size, NETDEV_ALIGN);  </span><br><span class="line">  alloc_size += sizeof_priv;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> p = kzalloc(alloc_size, GFP_KERNEL);  </span><br><span class="line"> dev = PTR_ALIGN(p, NETDEV_ALIGN);  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">//网桥设备初始化  </span></span><br><span class="line"> dev-&gt;... = ...;  </span><br><span class="line"> setup(dev); <span class="comment">//setup是一个函数指针，实际使用的是 br_dev_setup  </span></span><br><span class="line">  </span><br><span class="line"> ...  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<p>在上述代码中。kzalloc 是用来在内核态申请内核内存的。需要注意的是，申请的内存大小是一个 struct net_device 再加上一个 struct net_bridge（第一个参数传进来的）。一次性就申请了两个内核对象，这说明<strong>bridge 在内核中是由两个内核数据结构来表示的，分别是 struct net_device 和 struct net_bridge。</strong></p>
<p>申请完了一家紧接着调用 setup，这实际是外部传入的 br_dev_setup 函数。在这个函数内部进行进一步的初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/bridge/br_device.c  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">br_dev_setup</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>  </span><br><span class="line">&#123;  </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">net_bridge</span> *<span class="title">br</span> =</span> netdev_priv(dev);  </span><br><span class="line"> dev-&gt;... = ...;  </span><br><span class="line"> br-&gt;... = ...;  </span><br><span class="line"> ...  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<p><strong>总之，brctl addbr br0 命令主要就是完成了 bridge 内核对象（struct net_device 和 struct net_bridge）的申请以及初始化。</strong></p>
<h2 id="三、添加设备"><a href="#三、添加设备" class="headerlink" title="三、添加设备"></a>三、添加设备</h2><p>调用 <code> brctl addif br0 veth0</code>
 给网桥添加设备的时候，会将 veth 设备以虚拟的方式连到网桥上。当添加了若干个 veth 以后，内核中对象的大概逻辑图如下。</p>
<p><img src="/img/wiki-linux-network-bridge/7.jpg"></p>
<p>其中 veth 是由 struct net_device来表示，bridge 的虚拟插口是由 struct net_bridge_port 来表示。我们接下来看看源码，是如何达成上述的逻辑结果的。  </p>
<p>添加设备会调用到 net&#x2F;bridge&#x2F;br_if.c 下面的 br_add_if。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/bridge/br_if.c  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">br_add_if</span><span class="params">(<span class="keyword">struct</span> net_bridge *br, <span class="keyword">struct</span> net_device *dev)</span>  </span><br><span class="line">&#123;  </span><br><span class="line"> <span class="comment">// 申请一个 net_bridge_port  </span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span>;</span>  </span><br><span class="line"> p = new_nbp(br, dev);  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 注册设备帧接收函数  </span></span><br><span class="line"> err = netdev_rx_handler_register(dev, br_handle_frame, p);  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 添加到 bridge 的已用端口列表里  </span></span><br><span class="line"> list_add_rcu(&amp;p-&gt;<span class="built_in">list</span>, &amp;br-&gt;port_list);  </span><br><span class="line">  </span><br><span class="line"> ......  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<p>这个函数中的第二个参数 dev 传入的是要添加的设备。在本文中，就可以认为是 veth 的其中一头。比较关键的是 net_bridge_port 这个结构体，它模拟的是物理交换机上的一个插口。它起到一个连接的作用，把 veth 和 bridge 给连接了起来。见 new_nbp 源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/bridge/br_if.c  </span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> net_bridge_port *<span class="title function_">new_nbp</span><span class="params">(<span class="keyword">struct</span> net_bridge *br,  </span></span><br><span class="line"><span class="params">           <span class="keyword">struct</span> net_device *dev)</span>  </span><br><span class="line">&#123;  </span><br><span class="line"> <span class="comment">//申请插口对象  </span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span>;</span>  </span><br><span class="line"> p = kzalloc(<span class="keyword">sizeof</span>(*p), GFP_KERNEL);  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">//初始化插口  </span></span><br><span class="line"> index = find_portno(br);  </span><br><span class="line"> p-&gt;br = br;  </span><br><span class="line"> p-&gt;dev = dev;  </span><br><span class="line"> p-&gt;port_no = index;  </span><br><span class="line"> ...  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<p>在 new_nbp 中，先是申请了代表插口的内核对象。find_portno 是在当前 bridge 下寻找一个可用的端口号。接下来插口对象通过 <code> p-&gt;br = br</code>
 和 bridge 设备关联了起来，通过 <code> p-&gt;dev = dev</code>
 和代表 veth 设备的 dev 对象也建立了联系。</p>
<p>在 br_add_if 中还调用 netdev_rx_handler_register 注册了设备帧接收函数，设置 veth 上的 rx_handler 为 br_handle_frame。<strong>后面在接收包的时候会回调到它</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">netdev_rx_handler_register</span><span class="params">(<span class="keyword">struct</span> net_device *dev,  </span></span><br><span class="line"><span class="params">          <span class="type">rx_handler_func_t</span> *rx_handler,  </span></span><br><span class="line"><span class="params">          <span class="type">void</span> *rx_handler_data)</span>  </span><br><span class="line">&#123;  </span><br><span class="line"> ...   </span><br><span class="line"> rcu_assign_pointer(dev-&gt;rx_handler_data, rx_handler_data);  </span><br><span class="line"> rcu_assign_pointer(dev-&gt;rx_handler, rx_handler);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<h2 id="四、数据包处理过程"><a href="#四、数据包处理过程" class="headerlink" title="四、数据包处理过程"></a>四、数据包处理过程</h2><p>在<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247484058&idx=1&sn=a2621bc27c74b313528eefbc81ee8c0f&scene=21#wechat_redirect">图解Linux网络包接收过程</a>中我们讲到过接收包的完整流程。数据包会被网卡先从到 RingBuffer 中，然后依次经过硬中断、软中断处理。在软中断中再依次把包送到设备层、协议栈，最后唤醒应用程序。</p>
<p>不过，拿 veth 设备来举例，如果它连接到了网桥上的话，在设备层的 __netif_receive_skb_core 函数中和上述过程有所不同。连在 bridge 上的 veth 在收到数据包的时候，不会进入协议栈，而是会进入网桥处理。网桥找到合适的转发口（另一个 veth），通过这个 veth 把数据转发出去。工作流程如下图。</p>
<p><img src="/img/wiki-linux-network-bridge/8.jpg"></p>
<p>我们从 veth1_p 设备的接收看起，所有的设备的接收都一样，都会进入 __netif_receive_skb_core 设备层的关键函数。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/core/dev.c  </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __netif_receive_skb_core(<span class="keyword">struct</span> sk_buff *skb, <span class="type">bool</span> pfmemalloc)  </span><br><span class="line">&#123;  </span><br><span class="line"> ...  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">// tcpdump 抓包点  </span></span><br><span class="line"> list_for_each_entry_rcu(...);  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 执行设备的 rx_handler（也就是 br_handle_frame）  </span></span><br><span class="line"> rx_handler = rcu_dereference(skb-&gt;dev-&gt;rx_handler);  </span><br><span class="line"> <span class="keyword">if</span> (rx_handler) &#123;  </span><br><span class="line">  <span class="keyword">switch</span> (rx_handler(&amp;skb)) &#123;   </span><br><span class="line">  <span class="keyword">case</span> RX_HANDLER_CONSUMED:  </span><br><span class="line">   ret = NET_RX_SUCCESS;  </span><br><span class="line">   <span class="keyword">goto</span> unlock;  </span><br><span class="line">  &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 送往协议栈  </span></span><br><span class="line"> <span class="comment">//...  </span></span><br><span class="line">  </span><br><span class="line">unlock:  </span><br><span class="line"> rcu_read_unlock();  </span><br><span class="line">out:  </span><br><span class="line"> <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<p>在 __netif_receive_skb_core 中先是过了 tcpdump 的抓包点，然后查找和执行了 rx_handler。在上面小节中我们看到，把 veth 连接到网桥上的时候，veth 对应的内核对象 dev 中的 rx_handler 被设置成了 br_handle_frame。<strong>所以连接到网桥上的 veth 在收到包的时候，会将帧送入到网桥处理函数 br_handle_frame 中</strong>。</p>
<p>另外要注意的是网桥函数处理完的话，一般来说就 goto unlock 退出了。和普通的网卡数据包接收相比，并不会往下再送到协议栈了。</p>
<p>接着来看下网桥是咋工作的吧，进入到 br_handle_frame 中来搜寻。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/bridge/br_input.c  </span></span><br><span class="line"><span class="type">rx_handler_result_t</span> <span class="title function_">br_handle_frame</span><span class="params">(<span class="keyword">struct</span> sk_buff **pskb)</span>  </span><br><span class="line">&#123;  </span><br><span class="line"> ...  </span><br><span class="line">  </span><br><span class="line">forward:  </span><br><span class="line"> NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, skb, skb-&gt;dev, <span class="literal">NULL</span>,  </span><br><span class="line">   br_handle_frame_finish);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<p>上面我对 br_handle_frame 的逻辑进行了充分的简化，简化后它的核心就是调用 br_handle_frame_finish。同样 br_handle_frame_finish 也有点小复杂。本文中，我们主要想了解的 Docker 场景下 bridge 上的 veth 设备转发。所以根据这个场景，我又对该函数进行了充分的简化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/bridge/br_input.c  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">br_handle_frame_finish</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>  </span><br><span class="line">&#123;    </span><br><span class="line"> <span class="comment">// 获取 veth 所连接的网桥端口、以及网桥设备  </span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span> =</span> br_port_get_rcu(skb-&gt;dev);  </span><br><span class="line"> br = p-&gt;br;  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 更新和查找转发表  </span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_fdb_entry</span> *<span class="title">dst</span>;</span>  </span><br><span class="line"> br_fdb_update(br, p, eth_hdr(skb)-&gt;h_source, vid);  </span><br><span class="line"> dst = __br_fdb_get(br, dest, vid)  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 转发  </span></span><br><span class="line"> <span class="keyword">if</span> (dst) &#123;  </span><br><span class="line">  br_forward(dst-&gt;dst, skb, skb2);  </span><br><span class="line"> &#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<p>在硬件中，交换机和集线器的主要区别就是它会智能地把数据送到正确的端口上去，而不会像集线器那样给所有的端口都群发一遍。所以在上面的函数中，我们看到了更新和查找转发表的逻辑。这就是网桥在学习，它会根据它的自学习结果来工作。</p>
<p>在找到要送往的端口后，下一步就是调用 br_forward &#x3D;&gt; __br_forward 进入真正的转发流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/bridge/br_forward.c  </span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __br_forward(<span class="type">const</span> <span class="keyword">struct</span> net_bridge_port *to, <span class="keyword">struct</span> sk_buff *skb)  </span><br><span class="line">&#123;  </span><br><span class="line"> <span class="comment">// 将 skb 中的 dev 改成新的目的 dev  </span></span><br><span class="line"> skb-&gt;dev = to-&gt;dev;  </span><br><span class="line">  </span><br><span class="line"> NF_HOOK(NFPROTO_BRIDGE, NF_BR_FORWARD, skb, indev, skb-&gt;dev,  </span><br><span class="line">  br_forward_finish);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<p>在 __br_forward 中，将 skb 上的设备 dev 改为了新的目的 dev。</p>
<p><img src="/img/wiki-linux-network-bridge/9.jpg"></p>
<p>然后调用 br_forward_finish 进入发送流程。在 br_forward_finish 里会依次调用 br_dev_queue_push_xmit、dev_queue_xmit。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/bridge/br_forward.c  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">br_forward_finish</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>  </span><br><span class="line">&#123;  </span><br><span class="line"> <span class="keyword">return</span> NF_HOOK(NFPROTO_BRIDGE, NF_BR_POST_ROUTING, skb, <span class="literal">NULL</span>, skb-&gt;dev,  </span><br><span class="line">         br_dev_queue_push_xmit);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">br_dev_queue_push_xmit</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>  </span><br><span class="line">&#123;  </span><br><span class="line"> dev_queue_xmit(skb);  </span><br><span class="line"> ...  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<p>dev_queue_xmit 就是发送函数，在上一篇<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247486424&idx=1&sn=d66fe4ebf1cd9e5079606f71a0169697&scene=21#wechat_redirect">《轻松理解 Docker 网络虚拟化基础之 veth 设备！》</a>中我们介绍过，后续的发送过程就是 dev_queue_xmit &#x3D;&gt; dev_hard_start_xmit &#x3D;&gt; veth_xmit。在 veth_xmit 中会获取到当前 veth 的对端，然后把数据给它发送过去。</p>
<p><img src="/img/wiki-linux-network-bridge/10.jpg"></p>
<p>至此，bridge 上的转发流程就算是完毕了。要注意到的是，整个 bridge 的工作的源码都是在 net&#x2F;core&#x2F;dev.c 或 net&#x2F;bridge 目录下。都是在设备层工作的。这也就充分印证了我们经常说的 bridge（物理交换机也一样） 是二层上的设备。  </p>
<p>接下来，收到网桥发过来数据的 veth 会把数据包发送给它的对端 veth2，veth2再开始自己的数据包接收流程。</p>
<p><img src="/img/wiki-linux-network-bridge/11.jpg"></p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>所谓网络虚拟化，其实用一句话来概括就是<strong>用软件来模拟实现真实的物理网络连接</strong>。</p>
<p>Linux 内核中的 bridge 模拟实现了物理网络中的交换机的角色。和物理网络类似，可以将虚拟设备插入到 bridge 上。不过和物理网络有点不一样的是，一对儿 veth 插入 bridge 的那端其实就不是设备了，可以理解为退化成了一个网线插头。</p>
<p>当 bridge 接入了多对儿 veth 以后，就可以通过自身实现的网络包转发的功能来让不同的 veth 之间互相通信了。</p>
<p>回到 Docker 的使用场景上来举例，完整的 Docker 1 和 Docker 2 通信的过程是这样的：</p>
<p><img src="/img/wiki-linux-network-bridge/12.jpg"></p>
<p>大致步骤是：</p>
<ul>
<li>1.Docker1 往 veth1 上发送数据</li>
<li>2.由于 veth1_p 是 veth1 的 pair， 所以这个虚拟设备上可以收到包</li>
<li>3.veth 收到包以后发现自己是连在网桥上的，于是乎进入网桥处理。在网桥设备上寻找要转发到的端口，这时找到了 veth2_p 开始发送。网桥完成了自己的转发工作</li>
<li>4.veth2 作为 veth2_p 的对端，收到了数据包</li>
<li>5.Docker2 里的就可以从 veth2 设备上收到数据了</li>
</ul>
<p>觉得这个流程图还不过瘾？那我们再继续拉大视野，从两个 Docker 的用户态来开始看一看。</p>
<p><img src="/img/wiki-linux-network-bridge/13.jpg"></p>
<p>Docker 1 在需要发送数据的时候，先通过 send 系统调用发送，这个发送会执行到协议栈进行协议头的封装等处理。经由邻居子系统找到要使用的设备（veth1）后，从这个设备将数据发送出去，veth1 的对端 veth1_p 会收到数据包。  </p>
<p>收到数据的 veth1_p 是一个连接在 bridge 上的设备，这时候 bridge 会接管该 veth 的数据接收过程。从自己连接的所有设备中查找目的设备。找到 veth2_p 以后，调用该设备的发送函数将数据发送出去。同样 veth2_p 的对端 veth2 即将收到数据。</p>
<p>其中 veth2 收到数据后，将和 lo、eth0 等设备一样，进入正常的数据接收处理过程。Docker 2 中的用户态进程将能够收到 Docker 1 发送过来的数据了就。</p>
<p>怎么样，今天你有没有更深入地理解了 Docker 的工作原理呢？最后转发到朋友圈，让你的朋友们也一起来学学吧~~~</p>
<article class="message message-immersive is-primary">
<div class="message-body">
<i class="fas fa-globe-asia mr-2"></i>本文来自
<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247486949&idx=1&sn=51bf822b1ee4f6a667d6253965d49201&scene=21#wechat_redirect">开发内功修炼</a>.
</div>
</article>

</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Linux%E7%BD%91%E7%BB%9C/">Linux网络</a></div><!--!--><div><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6757924689439593" crossOrigin="anonymous"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6757924689439593" data-ad-slot="2352785969"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/pages/wiki-linux-network-namespace/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">一文了解 Linux network namespace</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/pages/wiki-linux-network-veth/"><span class="level-item">一文了解 Linux 虚拟网络设备veth</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div style="width:100%"><script src="https://giscus.app/client.js" data-repo="thetechstack/thetechstack.github.io" data-repo-id="R_kgDOG6Ti1Q" data-category="Announcements" data-category-id="DIC_kwDOG6Ti1c4COQtm" data-mapping="pathname" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="zh-CN" crossOrigin="anonymous" async></script></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一、如何使用-bridge"><span class="level-left"><span class="level-item">1</span><span class="level-item">一、如何使用 bridge</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-创建两个不同的网络"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">1.1 创建两个不同的网络</span></span></a></li><li><a class="level is-mobile" href="#1-2-把两个网络连接到一起"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">1.2 把两个网络连接到一起</span></span></a></li><li><a class="level is-mobile" href="#1-3-网络连通测试"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">1.3 网络连通测试</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二、Bridge-是如何创建出来的"><span class="level-left"><span class="level-item">2</span><span class="level-item">二、Bridge 是如何创建出来的</span></span></a></li><li><a class="level is-mobile" href="#三、添加设备"><span class="level-left"><span class="level-item">3</span><span class="level-item">三、添加设备</span></span></a></li><li><a class="level is-mobile" href="#四、数据包处理过程"><span class="level-left"><span class="level-item">4</span><span class="level-item">四、数据包处理过程</span></span></a></li><li><a class="level is-mobile" href="#五、总结"><span class="level-left"><span class="level-item">5</span><span class="level-item">五、总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Feed%E6%9C%8D%E5%8A%A1/"><span class="tag">Feed服务</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Knative/"><span class="tag">Knative</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kubernetes/"><span class="tag">Kubernetes</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux%E7%BD%91%E7%BB%9C/"><span class="tag">Linux网络</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Serverless/"><span class="tag">Serverless</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Yarn/"><span class="tag">Yarn</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/"><span class="tag">分布式一致性</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9C%A8%E7%A6%BB%E7%BA%BF%E6%B7%B7%E9%83%A8/"><span class="tag">在离线混部</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="tag">大数据</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%99%BA%E8%83%BD%E8%BF%90%E7%BB%B4/"><span class="tag">智能运维</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96/"><span class="tag">网络虚拟化</span><span class="tag">3</span></a></div></div></div></div></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg"></figure><p class="is-size-6 is-block">公众号：面向问题编程</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">48</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">11</p></a></div></div></nav></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3/"><span class="level-start"><span class="level-item">一文了解</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5/"><span class="level-start"><span class="level-item">技术实践</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"><span class="level-start"><span class="level-item">技术架构</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BB%BC%E8%BF%B0/"><span class="level-start"><span class="level-item">综述</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%97%AE%E9%A2%98/"><span class="level-start"><span class="level-item">问题</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="面向问题编程" height="28"></a><p class="is-size-7"><span>&copy; 2022 面向问题编程</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lg-zoom@1.3.0/dist/lg-zoom.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>