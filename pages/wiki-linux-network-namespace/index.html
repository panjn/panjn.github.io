<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>一文了解 Linux network namespace - 面向问题编程</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="面向问题编程"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="面向问题编程"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="大家好，我是飞哥！ 在 Linux 上通过 veth 我们可以创建出许多的虚拟设备。通过 Bridge 模拟以太网交换机的方式可以让这些网络设备之间进行通信。不过虚拟化中还有很重要的一步，那就是隔离。借用 Docker 的概念来说，那就是不能让 A 容器用到 B 容器的设备，甚至连看一眼都不可以。只有这样才能保证不同的容器之间复用硬件资源的同时，还不会影响其它容器的正常运行。 在 Linux 上实"><meta property="og:type" content="blog"><meta property="og:title" content="一文了解 Linux network namespace"><meta property="og:url" content="https://www.heapoverflow.cn/pages/wiki-linux-network-namespace/"><meta property="og:site_name" content="面向问题编程"><meta property="og:description" content="大家好，我是飞哥！ 在 Linux 上通过 veth 我们可以创建出许多的虚拟设备。通过 Bridge 模拟以太网交换机的方式可以让这些网络设备之间进行通信。不过虚拟化中还有很重要的一步，那就是隔离。借用 Docker 的概念来说，那就是不能让 A 容器用到 B 容器的设备，甚至连看一眼都不可以。只有这样才能保证不同的容器之间复用硬件资源的同时，还不会影响其它容器的正常运行。 在 Linux 上实"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.heapoverflow.cn/img/wiki-linux-network-namespace/0.jpg"><meta property="article:published_time" content="2022-03-27T09:09:36.335Z"><meta property="article:modified_time" content="2022-03-30T04:23:28.881Z"><meta property="article:author" content="面向问题编程"><meta property="article:tag" content="Linux网络"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/wiki-linux-network-namespace/0.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.heapoverflow.cn/pages/wiki-linux-network-namespace/"},"headline":"一文了解 Linux network namespace","image":["https://www.heapoverflow.cn/img/wiki-linux-network-namespace/0.jpg"],"datePublished":"2022-03-27T09:09:36.335Z","dateModified":"2022-03-30T04:23:28.881Z","author":{"@type":"Person","name":"面向问题编程"},"publisher":{"@type":"Organization","name":"面向问题编程","logo":{"@type":"ImageObject","url":"https://www.heapoverflow.cn/img/logo.svg"}},"description":"大家好，我是飞哥！ 在 Linux 上通过 veth 我们可以创建出许多的虚拟设备。通过 Bridge 模拟以太网交换机的方式可以让这些网络设备之间进行通信。不过虚拟化中还有很重要的一步，那就是隔离。借用 Docker 的概念来说，那就是不能让 A 容器用到 B 容器的设备，甚至连看一眼都不可以。只有这样才能保证不同的容器之间复用硬件资源的同时，还不会影响其它容器的正常运行。 在 Linux 上实"}</script><link rel="canonical" href="https://www.heapoverflow.cn/pages/wiki-linux-network-namespace/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-ETGL163DQH" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-ETGL163DQH');</script><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-6757924689439593" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="面向问题编程" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories/%E9%97%AE%E9%A2%98/">问题</a><a class="navbar-item" href="/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/">技术架构</a><a class="navbar-item" href="/categories/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3/">一文了解</a></div><div class="navbar-end"><a class="navbar-item" rel="noopener" title="分类" href="/categories">分类</a><a class="navbar-item" rel="noopener" title="标签" href="/tags">标签</a><a class="navbar-item" rel="noopener" title="归档" href="/archives">归档</a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/wiki-linux-network-namespace/0.jpg" alt="一文了解 Linux network namespace"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-27T09:09:36.335Z" title="2022/3/27 下午5:09:36">2022-03-27</time>发表</span><span class="level-item"><time dateTime="2022-03-30T04:23:28.881Z" title="2022/3/30 下午12:23:28">2022-03-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3/">一文了解</a></span><span class="level-item">37 分钟读完 (大约5588个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">一文了解 Linux network namespace</h1><div class="content"><p>大家好，我是飞哥！</p>
<p>在 Linux 上通过 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247486424&idx=1&sn=d66fe4ebf1cd9e5079606f71a0169697&scene=21#wechat_redirect">veth</a> 我们可以创建出许多的虚拟设备。通过 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247486949&idx=1&sn=51bf822b1ee4f6a667d6253965d49201&scene=21#wechat_redirect">Bridge</a> 模拟以太网交换机的方式可以让这些网络设备之间进行通信。不过虚拟化中还有很重要的一步，那就是隔离。借用 Docker 的概念来说，那就是不能让 A 容器用到 B 容器的设备，甚至连看一眼都不可以。只有这样才能保证不同的容器之间复用硬件资源的同时，还不会影响其它容器的正常运行。</p>
<p>在 Linux 上实现隔离的技术手段就是 namespace。通过 namespace 可以隔离容器的进程 PID、文件系统挂载点、主机名等多种资源。不过我们今天重点要介绍的是网络 namespace，简称 netns。它可以为不同的命名空间从<strong>逻辑上</strong>提供独立的网络协议栈，具体包括网络设备、路由表、arp表、iptables、以及套接字（socket）等。使得不同的网络空间就都好像运行在独立的网络中一样。</p>
<span id="more"></span>

<p><img src="/img/wiki-linux-network-namespace/0.jpg"></p>
<p>你是不是和飞哥一样，也很好奇 Linux 底层到底是如何实现网络隔离的？我们今天来好好挖一挖 netns 的内部实现。  </p>
<h2 id="一、如何使用-netns"><a href="#一、如何使用-netns" class="headerlink" title="一、如何使用 netns"></a>一、如何使用 netns</h2><p>由于我们平时的开发工作很少涉及网络空间，所以我们先来看一下网络空间是如何使用的吧。我们来创建一个新的命名空间net1。再创建一对儿 veth，将 veth 的一头放到 net1 中。分别查看一下母机和 net1 空间内的 iptable、设备等。最后让两个命名空间之间进行通信。</p>
<p><img src="/img/wiki-linux-network-namespace/1.jpg"></p>
<p>下面是详细的使用过程。首先我们先来创建一个新的网络命名空间 - net1。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># ip netns add net1</span></span><br></pre></td></tr></table></figure>

<p>来查看一下它的 iptable、路由表、以及网络设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># ip netns exec net1 route</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line"></span><br><span class="line"><span class="meta"># ip netns exec net1 iptables -L</span></span><br><span class="line">ip netns exec net1 iptables -L</span><br><span class="line">Chain <span class="title function_">INPUT</span> <span class="params">(policy ACCEPT)</span></span><br><span class="line">target     prot opt source               destination</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta"># ip netns exec net1 ip link list</span></span><br><span class="line">lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br></pre></td></tr></table></figure>

<p>由于是新创建的 netns，所以上述的输出中路由表、iptable规则都是空的。不过这个命名空间中初始的情况下就存在一个 lo 本地环回设备，只不过默认是 DOWN（未启动）状态。</p>
<p>接下来我们创建一对儿 veth，并把 veth 的一头添加给它。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># ip link add veth1 type veth peer name veth1_p</span></span><br><span class="line"><span class="meta"># ip link set veth1 netns net1</span></span><br></pre></td></tr></table></figure>

<p>在母机上查看一下当前的设备，发现已经看不到 veth1 这个网卡设备了，只能看到 veth1_p。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># ip link list</span></span><br><span class="line"><span class="number">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="number">65536</span> ...</span><br><span class="line"><span class="number">2</span>: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="number">1500</span> ...</span><br><span class="line"><span class="number">3</span>: eth1: &lt;BROADCAST,MULTICAST&gt; mtu <span class="number">1500</span> ...</span><br><span class="line"><span class="number">45</span>: veth1_p@if46: &lt;BROADCAST,MULTICAST&gt; mtu <span class="number">1500</span> qdisc noop state DOWN mode DEFAULT qlen <span class="number">1000</span></span><br><span class="line">    link/ether <span class="number">0</span>e:<span class="number">13</span>:<span class="number">18</span>:<span class="number">0</span>a:<span class="number">98</span>:<span class="number">9</span>c brd ff:ff:ff:ff:ff:ff link-netnsid <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这个新设备已经跑到 net1 这个网络空间里了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># ip netns exec net1 ip link list</span></span><br><span class="line"><span class="number">1</span>: lo: &lt;LOOPBACK&gt; mtu <span class="number">65536</span> ...</span><br><span class="line"><span class="number">46</span>: veth1@if45: &lt;BROADCAST,MULTICAST&gt; mtu <span class="number">1500</span> qdisc noop state DOWN mode DEFAULT qlen <span class="number">1000</span></span><br><span class="line">    link/ether <span class="number">7</span>e:cd:ec:<span class="number">1</span>c:<span class="number">5</span>d:<span class="number">7</span>a brd ff:ff:ff:ff:ff:ff link-netnsid <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>把这对儿 veth 分别配置上 ip，并把它们启动起来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># ip addr add 192.168.0.100/24 dev veth1_p</span></span><br><span class="line"><span class="meta"># ip netns exec net1 ip addr add 192.168.0.101/24 dev veth1</span></span><br><span class="line"><span class="meta"># ip netns exec net1 ip link set dev veth1_p up </span></span><br><span class="line"><span class="meta"># ip netns exec net1 ip link set dev veth1 up </span></span><br></pre></td></tr></table></figure>

<p>在母机和 net1 中分别执行 ifconfig 查看当前启动的网络设备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># ifconfig</span></span><br><span class="line">eth0: ...</span><br><span class="line">lo: ...</span><br><span class="line">veth1_p: flags=<span class="number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        inet <span class="number">192.168</span><span class="number">.0</span><span class="number">.100</span>  netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="meta"># ip netns exec net1 ifconfig</span></span><br><span class="line">veth1: flags=<span class="number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        inet <span class="number">192.168</span><span class="number">.0</span><span class="number">.101</span>  netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        ...       </span><br></pre></td></tr></table></figure>

<p>我们来让它和母机通信一下试试。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># ip netns exec net1 ping 192.168.0.100 -I veth1</span></span><br><span class="line">PING <span class="number">192.168</span><span class="number">.0</span><span class="number">.100</span> (<span class="number">192.168</span><span class="number">.0</span><span class="number">.100</span>) from <span class="number">192.168</span><span class="number">.0</span><span class="number">.101</span> veth1: <span class="number">56</span>(<span class="number">84</span>) bytes of data.</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">192.168</span><span class="number">.0</span><span class="number">.100</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">64</span> time=<span class="number">0.027</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">192.168</span><span class="number">.0</span><span class="number">.100</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">64</span> time=<span class="number">0.010</span> ms</span><br></pre></td></tr></table></figure>

<p>好了，现在一个新网络命名空间创建实验就结束了。在这个空间里，<strong>网络设备、路由表、arp表、iptables</strong>都是独立的，不会和母机上的冲突，也不会和其它空间里的产生干扰。而且还可以通过 veth 来和其它空间下的网络进行通信。</p>
<p>想快速做这个实验的同学可以使用我写的一个makefile，见 <a target="_blank" rel="noopener" href="https://github.com/yanfeizhang/coder-kung-fu/tree/main/tests/network/test05">https://github.com/yanfeizhang/coder-kung-fu/tree/main/tests/network/test05</a></p>
<h2 id="二、内核中-namespace-的定义"><a href="#二、内核中-namespace-的定义" class="headerlink" title="二、内核中 namespace 的定义"></a>二、内核中 namespace 的定义</h2><p>在内核中，很多组件都是和 namespace 有关系的，我们先来看看这个关联关系是如何定义的。后面我们再看下 namespace 本身的详细结构。</p>
<h3 id="2-1-归属到-namespace-的东东"><a href="#2-1-归属到-namespace-的东东" class="headerlink" title="2.1 归属到 namespace 的东东"></a>2.1 归属到 namespace 的东东</h3><p>在 Linux 中，很多我们平常熟悉的概念都是归属到某一个特定的网络 namespace 中的，比如进程、网卡设备、socket 等等。</p>
<p>Linux 中每个进程（线程）都是用 task_struct 来表示的。每个 task_struct 都要关联到一个 namespace 对象 nsproxy，而 nsproxy 又包含了 netns。对于网卡设备和 socket 来说，通过自己的成员来直接表明自己的归属。</p>
<p><img src="/img/wiki-linux-network-namespace/2.jpg"></p>
<p>拿网络设备来举例，只有归属到当前 netns 下的时候才能够通过 ifconfig 看到，否则是不可见的。我们详细来看看这几个数据结构的定义，先来看进程。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:include/linux/sched.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"> <span class="comment">/* namespaces */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> *<span class="title">nsproxy</span>;</span></span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名空间的核心数据结构是上面的这个 struct nsproxy。所有类型的 namespace（包括 pid、文件系统挂载点、网络栈等等）都是在这里定义的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: include/linux/nsproxy.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> &#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> *<span class="title">uts_ns</span>;</span> <span class="comment">// 主机名</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ipc_ns</span>;</span> <span class="comment">// IPC</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">mnt_ns</span>;</span> <span class="comment">// 文件系统挂载点</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">pid_ns</span>;</span> <span class="comment">// 进程标号</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">net</span>       *<span class="title">net_ns</span>;</span>  <span class="comment">// 网络协议栈</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中 struct net *net_ns 就是今天我们要讨论的网络命名空间。它的详细定义我们待会再说。我们接着再看表示网络设备的 struct net_device，它也是要归属到某一个网络空间下的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: include/linux/netdevice.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span>&#123;</span></span><br><span class="line"> <span class="comment">//设备名</span></span><br><span class="line"> <span class="type">char</span>   name[IFNAMSIZ];</span><br><span class="line"></span><br><span class="line"> <span class="comment">//网络命名空间</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">net</span>  *<span class="title">nd_net</span>;</span></span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的网络设备刚创建出来都是在宿主机默认网络空间下的。可以通过<code>ip link set 设备名 netns 网络空间名</code>将设备移动到另外一个空间里去。前面的实验里，当 veth 1 移动到 net1 下的时候，该设备在宿主机下“消失”了，在 net1 下就能看到了。</p>
<p>还有我们经常用的 socket，也是归属在某一个网络命名空间下的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_common</span> &#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">net</span>   *<span class="title">skc_net</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-网络-namespace-定义"><a href="#2-2-网络-namespace-定义" class="headerlink" title="2.2 网络 namespace 定义"></a>2.2 网络 namespace 定义</h3><p>本小节中，我们来看网络 namespace 的主要数据结构 struct net 的定义。</p>
<p><img src="/img/wiki-linux-network-namespace/3.jpg"></p>
<p>可见每个 net 下都包含了自己的路由表、iptable 以及内核参数配置等等。我们来看具体的代码。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:include/net/net_namespace.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> &#123;</span></span><br><span class="line"> <span class="comment">//每个 net 中都有一个回环设备</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span>       *<span class="title">loopback_dev</span>;</span>          <span class="comment">/* The loopback */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//路由表、netfilter都在这里</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">netns_ipv4</span> <span class="title">ipv4</span>;</span></span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span>  proc_inum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上述定义可见，每一个 netns 中都有一个 loopback_dev，这就是为什么我们在第一节中看到刚创建出来的空间里就能看到一个 lo 设备的底层原因。</p>
<p>网络 netspace 中最核心的数据结构是 <code>struct netns_ipv4 ipv4</code>。在这个数据结构里，定义了每一个网络空间专属的路由表、ipfilter 以及各种内核参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: include/net/netns/ipv4.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netns_ipv4</span> &#123;</span></span><br><span class="line"> <span class="comment">//路由表 </span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">fib_table</span> *<span class="title">fib_local</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">fib_table</span> *<span class="title">fib_main</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">fib_table</span> *<span class="title">fib_default</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//ip表</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">xt_table</span>  *<span class="title">iptable_filter</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">xt_table</span>  *<span class="title">iptable_raw</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">xt_table</span>  *<span class="title">arptable_filter</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//内核参数</span></span><br><span class="line"> <span class="type">long</span> sysctl_tcp_mem[<span class="number">3</span>];</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、网络-namespace-的创建"><a href="#三、网络-namespace-的创建" class="headerlink" title="三、网络 namespace 的创建"></a>三、网络 namespace 的创建</h2><p>回顾第一小节中，我们实验步骤主要是创建了一个 netns，为其添加了一个 veth 设备。在这节中我们来窥探一下刚才的实验步骤内部到底是如何运行的。</p>
<h3 id="3-1-进程与网络命名空间"><a href="#3-1-进程与网络命名空间" class="headerlink" title="3.1 进程与网络命名空间"></a>3.1 进程与网络命名空间</h3><p>Linux 上存在一个默认的网络命名空间，Linux 中的 1 号进程初始使用该默认空间。Linux 上其它所有进程都是由 1 号进程派生出来的，在派生 clone 的时候如果没有额外特别指定，所有的进程都将共享这个默认网络空间。</p>
<p><img src="/img/wiki-linux-network-namespace/4.jpg"></p>
<p>在 clone 里可以指定创建新进程时的 flag，都是 CLONE_ 开头的。和 namespace 有的的标志位有 CLONE_NEWIPC、CLONE_NEWNET、CLONE_NEWNS、CLONE_NEWPID 等等。如果在创建进程时指定了 CLONE_NEWNET 标记位，那么该进程将会创建并使用新的 netns。  </p>
<p>其实内核提供了三种操作命名空间的方式，分别是 clone、setns 和 unshare。本文中我们只用 clone 来举例，ip netns add 使用的是 unshare，原理和 clone 是类似的。</p>
<p><img src="/img/wiki-linux-network-namespace/5.jpg"></p>
<p>我们先来看下默认的网络命名空间的初始化过程。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: init/init_task.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">init_task</span> =</span> INIT_TASK(init_task);</span><br><span class="line"></span><br><span class="line"><span class="comment">//file: include/linux/init_task.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_TASK(tsk)  \</span></span><br><span class="line"><span class="meta">&#123;</span></span><br><span class="line"> ...</span><br><span class="line">  .nsproxy = &amp;init_nsproxy, \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是在初始化第 1 号进程。可见 nsproxy 是已经创建好的 init_nsproxy。再看 init_nsproxy 是如何创建的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: kernel/nsproxy.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> <span class="title">init_nsproxy</span> =</span> &#123;</span><br><span class="line"> .uts_ns = &amp;init_uts_ns,</span><br><span class="line"> .ipc_ns = &amp;init_ipc_ns,</span><br><span class="line"> .mnt_ns = <span class="literal">NULL</span>,</span><br><span class="line"> .pid_ns = &amp;init_pid_ns,</span><br><span class="line"> .net_ns = &amp;init_net,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>初始的 init_nsproxy 里将多个命名空间都进行了初始化，其中我们关注的网络命名空间，<strong>用的是默认网络空间 init_net</strong>。它是系统初始化的时候就创建好的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/core/net_namespace.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> <span class="title">init_net</span> =</span> &#123;</span><br><span class="line"> .dev_base_head = LIST_HEAD_INIT(init_net.dev_base_head),</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(init_net);</span><br><span class="line"></span><br><span class="line"><span class="comment">//file: net/core/net_namespace.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">net_ns_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> setup_net(&amp;init_net, &amp;init_user_ns);</span><br><span class="line"> ...</span><br><span class="line"> register_pernet_subsys(&amp;net_ns_ops);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 setup_net 方法中对这个默认网络命名空间进行初始化。</p>
<p>看到这里我们清楚了 1 号进程的命名空间初始化过程。Linux 中所有的进程都是由这个 1 号进程创建的。如果创建子进程过程中没有指定 CLONE_NEWNET 这个 flag 的话，就直接还使用这个默认的网络空间。</p>
<p>如果创建进程过程中指定了 CLONE_NEWNET，那么就会重新申请一个网络命名空间出来。见如下的关键函数 copy_net_ns（它的调用链是 do_fork &#x3D;&gt; copy_process &#x3D;&gt; copy_namespaces &#x3D;&gt; create_new_namespaces &#x3D;&gt; copy_net_ns）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/core/net_namespace.c</span></span><br><span class="line"><span class="keyword">struct</span> net *<span class="title function_">copy_net_ns</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> user_namespace *user_ns, <span class="keyword">struct</span> net *old_net)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 重要！！！</span></span><br><span class="line"> <span class="comment">// 不指定 CLONE_NEWNET 就不会创建新的网络命名空间</span></span><br><span class="line"> <span class="keyword">if</span> (!(flags &amp; CLONE_NEWNET))</span><br><span class="line">  <span class="keyword">return</span> get_net(old_net);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//申请新网络命名空间并初始化</span></span><br><span class="line"> net = net_alloc();</span><br><span class="line"> rv = setup_net(net, user_ns);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记住 setup_net 是初始化网络命名空间的，这个函数接下来我们还会提到。</p>
<h3 id="3-2-命名空间内的网络子系统初始化"><a href="#3-2-命名空间内的网络子系统初始化" class="headerlink" title="3.2 命名空间内的网络子系统初始化"></a>3.2 命名空间内的网络子系统初始化</h3><p>命名空间内的各个组件都是在 setup_net 时初始化的，包括路由表、tcp 的 proc 伪文件系统、iptable 规则读取等等，所以这个小节也是蛮重要的。</p>
<p>由于内核网络模块的复杂性，在内核中将网络模块划分成了各个子系统。每个子系统都定义了一个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: include/net/net_namespace.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pernet_operations</span> &#123;</span></span><br><span class="line"> <span class="comment">// 链表指针</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 子系统的初始化函数</span></span><br><span class="line"> <span class="type">int</span> (*init)(<span class="keyword">struct</span> net *net);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 网络命名空间每个子系统的退出函数</span></span><br><span class="line"> <span class="type">void</span> (*<span class="built_in">exit</span>)(<span class="keyword">struct</span> net *net);</span><br><span class="line"> <span class="type">void</span> (*exit_batch)(<span class="keyword">struct</span> list_head *net_exit_list);</span><br><span class="line"> <span class="type">int</span> *id;</span><br><span class="line"> <span class="type">size_t</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>各个子系统通过调用 register_pernet_subsys 或 register_pernet_device 将其初始化函数注册到网络命名空间系统的全局链表 pernet_list 中。你在源码目录下用这两个函数搜索的话，会看到各个子系统的注册过程。</p>
<p><img src="/img/wiki-linux-network-namespace/6.jpg"></p>
<p>拿 register_pernet_subsys 来举例，我们来简单看下它是如何将子系统都注册到 pernet_list 中的。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/core/net_namespace.c</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">first_device</span> =</span> &amp;pernet_list;</span><br><span class="line"><span class="type">int</span> <span class="title function_">register_pernet_subsys</span><span class="params">(<span class="keyword">struct</span> pernet_operations *ops)</span></span><br><span class="line">&#123;</span><br><span class="line"> error =  register_pernet_operations(first_device, ops);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>register_pernet_operations 又会调用 __register_pernet_operations。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: include/net/net_namespace.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> for_each_net(VAR)    \</span></span><br><span class="line"><span class="meta"> list_for_each_entry(VAR, &amp;net_namespace_list, list)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//file: net/core/net_namespace.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __register_pernet_operations(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>,</span><br><span class="line">     <span class="keyword">struct</span> pernet_operations *ops)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line"></span><br><span class="line"> list_add_tail(&amp;ops-&gt;<span class="built_in">list</span>, <span class="built_in">list</span>);</span><br><span class="line"> <span class="keyword">if</span> (ops-&gt;init || (ops-&gt;id &amp;&amp; ops-&gt;size)) &#123;</span><br><span class="line">  for_each_net(net) &#123;</span><br><span class="line">   error = ops_init(ops, net);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面 list_add_tail 这一行，完成了将子系统传入的 struct pernet_operations *ops 链入到 pernet_list 中。并注意一下，for_each_net 是遍历了所有的网络命名空间，然后在这个空间内执行了 ops_init 初始化。</p>
<p>这个初始化是网络子系统在注册的时候调用的。同样当新的命名空间创建时，会遍历该全局变量 pernet_list，执行每个子模块注册上来的初始化函数。再回到我们 3.1.1 里提到的 setup_net 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/core/net_namespace.c</span></span><br><span class="line"><span class="type">static</span> __net_init <span class="type">int</span> <span class="title function_">setup_net</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> user_namespace *user_ns)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pernet_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"> list_for_each_entry(ops, &amp;pernet_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">  error = ops_init(ops, net);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//file: net/core/net_namespace.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ops_init</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> pernet_operations *ops, <span class="keyword">struct</span> net *net)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (ops-&gt;init)</span><br><span class="line">  err = ops-&gt;init(net);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建新命名空间调用到 setup_net 时，会通过 pernet_list 找到所有的网络子系统，把它们都 init 一遍。</p>
<p><strong>我们拿路由表来举例</strong>，路由表子系统通过 register_pernet_subsys 将 fib_net_ops 注册进来了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/ipv4/fib_frontend.c</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pernet_operations</span> <span class="title">fib_net_ops</span> =</span> &#123;</span><br><span class="line"> .init = fib_net_init,</span><br><span class="line"> .<span class="built_in">exit</span> = fib_net_exit,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">ip_fib_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> register_pernet_subsys(&amp;fib_net_ops);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样每当创建一个新的命名空间的时候，<strong>就会调用 fib_net_init 来创建一套独立的路由规则</strong>。</p>
<p><strong>再比如拿 iptable 中的 nat 表来说</strong>，也是一样。每当创建新命名空间的时候，<strong>就会调用 iptable_nat_net_init 创建一套新的表</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/ipv4/netfilter/iptable_nat.c</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pernet_operations</span> <span class="title">iptable_nat_net_ops</span> =</span> &#123;</span><br><span class="line"> .init = iptable_nat_net_init,</span><br><span class="line"> .<span class="built_in">exit</span> = iptable_nat_net_exit,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">iptable_nat_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> err = register_pernet_subsys(&amp;iptable_nat_net_ops);</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<h3 id="3-3-添加设备"><a href="#3-3-添加设备" class="headerlink" title="3.3 添加设备"></a>3.3 添加设备</h3><p>在一个设备刚刚创建出来的时候，它是属于默认网络命名空间 init_net 的，包括 veth 设备。不过可以在创建完后修改设备到新的网络命名空间。</p>
<p><img src="/img/wiki-linux-network-namespace/7.jpg"></p>
<p>拿 veth 设备来举例，它是在创建时的源码 alloc_netdev_mqs 中设置到 init_net 上的。(执行代码路径：veth_newlink &#x3D;&gt; rtnl_create_link &#x3D;&gt; alloc_netdev_mqs)  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: core/dev.c</span></span><br><span class="line"><span class="keyword">struct</span> net_device *<span class="title function_">alloc_netdev_mqs</span><span class="params">(...)</span></span><br><span class="line">&#123;</span><br><span class="line"> dev_net_set(dev, &amp;init_net);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//file: include/linux/netdevice.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dev_net_set</span><span class="params">(<span class="keyword">struct</span> net_device *dev,<span class="keyword">struct</span> net *net)</span></span><br><span class="line">&#123;</span><br><span class="line"> release_net(dev-&gt;nd_net);</span><br><span class="line"> dev-&gt;nd_net = hold_net(net);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行 修改设备所属的 namespace 的时候，会将 dev-&gt;nd_net 再指向新的 netns。对于 veth 来说，它包含了两个设备。这两个设备可以放在不同的 namespace 中。这就是 Docker 容器和其母机或者其它容器通信的基础。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: core/dev.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_change_net_namespace</span><span class="params">(<span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> net *net, ...)</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> dev_net_set(dev, net)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、在-namespace-下的网络收发"><a href="#四、在-namespace-下的网络收发" class="headerlink" title="四、在 namespace 下的网络收发"></a>四、在 namespace 下的网络收发</h2><p>在前面一节中，我们知道了内核是如何创建 netns 出来，也了解了网络设备是如何添加到其它命名空间里的。在这一小节，我们聊聊，当考虑到网络命名空间的时候，网络包的收发又是怎么样的呢？</p>
<h3 id="4-1-socket-与网络命名空间"><a href="#4-1-socket-与网络命名空间" class="headerlink" title="4.1 socket 与网络命名空间"></a>4.1 socket 与网络命名空间</h3><p>首先来考虑的就是我们熟悉的 socket。其实每个 socket 都是归属于某一个网络命名空间的，这个关联关系在上面的 2.1 小节提到过。</p>
<p>到底归属那个 netns，这是由创建这个 socket 的进程所属的 netns 来决定。当在某个进程里创建 socket 的时候，内核就会把当前进程的 nsproxy-&gt;net_ns 找出来，并把它赋值给 socket 上的网络命名空间成员 skc_net。</p>
<blockquote>
<p>在默认下，我们创建的 socket 都属于默认的网络命名空间 init_net</p>
</blockquote>
<p><img src="/img/wiki-linux-network-namespace/8.jpg"></p>
<p>我们来展开看下 socket 是如何被放到某个网络命名空间中的。在 socket 中，用来保存和网络命名空间归属关系的变量是 skc_net，如下。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: include/net/sock.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_common</span> &#123;</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">net</span>   *<span class="title">skc_net</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是 socket 创建的时候，内核中可以通过 current-&gt;nsproxy-&gt;net_ns 把当前进程所属的 netns 找出来，最终把 socket 中的 sk_net 成员和该命名空间建立好了联系。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/socket.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sock_create</span><span class="params">(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol, <span class="keyword">struct</span> socket **res)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> __sock_create(current-&gt;nsproxy-&gt;net_ns, family, type, protocol, res, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 socket_create 中，看到 current-&gt;nsproxy-&gt;net_ns 了吧，它获取到了进程的 netns。再依次经过__sock_create &#x3D;&gt; inet_create &#x3D;&gt; sk_alloc，调用到 sock_net_set 的时候，成功设置了新 socket 和 netns 的关联关系。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: include/net/sock.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sock_net_set</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> net *net)</span></span><br><span class="line">&#123;</span><br><span class="line"> write_pnet(&amp;sk-&gt;sk_net, net);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-网络包的收发过程"><a href="#4-2-网络包的收发过程" class="headerlink" title="4.2 网络包的收发过程"></a>4.2 网络包的收发过程</h3><p>网络包的接收和发送过程我们在这两篇文章里详细介绍过,<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247484058&idx=1&sn=a2621bc27c74b313528eefbc81ee8c0f&scene=21#wechat_redirect">图解Linux网络包接收过程</a> 和 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247485146&idx=1&sn=e5bfc79ba915df1f6a8b32b87ef0ef78&scene=21#wechat_redirect">25 张图，一万字，拆解 Linux 网络包发送过程</a>。</p>
<p>本小节的不再重复赘述这个收发过程，我们就以网络包发送过程中的路由功能为例，来看一下网络在传输的时候是如何使用到 netns 的。其它收发过程中的各个步骤也都是类似的。</p>
<p><img src="/img/wiki-linux-network-namespace/9.jpg"></p>
<p>大致的原理就是 socket 上记录了其归属的网络命名空间。<strong>需要查找路由表之前先找到该命名空间，再找到命名空间里的路由表，然后再开始执行查找</strong>。这样，各个命名空间中的路由过程就都隔离开了。  </p>
<p>我们来看详细的路由查找源码。在<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247485146&idx=1&sn=e5bfc79ba915df1f6a8b32b87ef0ef78&scene=21#wechat_redirect">25 张图，一万字，拆解 Linux 网络包发送过程</a> 中我们提到过在发送过程中在 IP 层的发送函数 ip_queue_xmit 中调用 ip_route_output_ports 来查找路由项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: net/ipv4/ip_output.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ip_queue_xmit</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> flowi *fl)</span></span><br><span class="line">&#123;</span><br><span class="line"> rt = ip_route_output_ports(sock_net(sk), fl4, sk,</span><br><span class="line">     daddr, inet-&gt;inet_saddr,</span><br><span class="line">     ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上面的 sock_net(sk) 这一步，在这里将 socket 上记录的命名空间 struct net *sk_net 给找了出来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: include/net/sock.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> net *<span class="title function_">sock_net</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> read_pnet(&amp;sk-&gt;sk_net);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到命名空间以后，就会将它(以 struct net * 指针的形式)一路透传到后面的各个函数中。在<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247485270&idx=1&sn=503534e9f0560bfcfbd4539e028e0d57&scene=21#wechat_redirect">127.0.0.1 之本机网络通信过程知多少 ?！</a> 中我们介绍了路由查找最后会执行到 fib_lookup，我们来看下这个函数的源码。</p>
<blockquote>
<p>路由查找的调用链条有点长，是 ip_route_output_ports &#x3D;&gt; -&gt;ip_route_output_flow &#x3D;&gt; __ip_route_output_key() &#x3D;&gt; ip_route_output_key_hash &#x3D;&gt; ip_route_output_key_hash_rcu）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: include/net/ip_fib.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">fib_lookup</span><span class="params">(<span class="keyword">struct</span> net *net, ...)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">fib_table</span> *<span class="title">table</span>;</span></span><br><span class="line"> table = fib_get_table(net, RT_TABLE_LOCAL);</span><br><span class="line"> table = fib_get_table(net, RT_TABLE_MAIN);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> fib_table *<span class="title function_">fib_get_table</span><span class="params">(<span class="keyword">struct</span> net *net, u32 id)</span></span><br><span class="line">&#123;</span><br><span class="line"> ptr = id == RT_TABLE_LOCAL ?</span><br><span class="line">  &amp;net-&gt;ipv4.fib_table_hash[TABLE_LOCAL_INDEX] :</span><br><span class="line">  &amp;net-&gt;ipv4.fib_table_hash[TABLE_MAIN_INDEX];</span><br><span class="line"> <span class="keyword">return</span> hlist_entry(ptr-&gt;first, <span class="keyword">struct</span> fib_table, tb_hlist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上述代码可见，在路由过程中是根据前面步骤中确定好的命名空间 struct net *net 来查找路由项的。不同的命名空间有不同的 net 变量，<strong>所以不同的 netns 中自然也就可以配置不同的路由表了</strong>。</p>
<p>网络收发过程中其它步骤也是类似的，涉及到需要隔离的地方，都是通过命名空间( struct net *) 去查找的。</p>
<h2 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h2><p>Linux 的网络 namespace 实现了独立协议栈的隔离。这个说法其实不是很准确，内核网络代码只有一套，并没有隔离。</p>
<p>它是通过为不同空间创建不同的 struct net 对象。每个 struct net 中都有独立的路由表、iptable 等数据结构。每个设备、每个 socket 上也都有指针指明自己归属那个 netns。通过这种方法从<strong>逻辑上看起来好像是真的有多个协议栈一样</strong>。</p>
<p><img src="/img/wiki-linux-network-namespace/10.jpg"></p>
<p>这样，就为一台物理上创建出多个<strong>逻辑上</strong>的协议栈，为 Docker 容器的诞生提供了可能。  </p>
<p><img src="/img/wiki-linux-network-namespace/0.jpg"></p>
<p>在上面的示例中，Docker1 和 Docker2 都可以分别拥有自己独立的网卡设备，配置自己的路由规则、iptable。从而使得他们的网络功能不会相互影响。  </p>
<p>怎么样，今天是不是对网络 namespace 理解更深了呢？转发 给你的朋友们也一起来学学吧~~~</p>
<article class="message message-immersive is-primary">
<div class="message-body">
<i class="fas fa-globe-asia mr-2"></i>本文来自
<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247487019&idx=1&sn=a0cbac49913071cd13e64ad5abd16d5c&chksm=a6e30f109194860672ddfe5ca8fedfb54f6f3b0998cacf438e6146b9103fbb6a4fb8baf59948&scene=178&cur_album_id=1532487451997454337#rd">开发内功修炼</a>.
</div>
</article>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Linux%E7%BD%91%E7%BB%9C/">Linux网络</a></div><!--!--><div><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6757924689439593" crossOrigin="anonymous"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6757924689439593" data-ad-slot="2352785969"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/pages/wiki-k8s-arch/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">一文了解 Kubernetes 整体架构</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/pages/wiki-linux-network-bridge/"><span class="level-item">一文了解 Linux 虚拟网络设备Bridge</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div style="width:100%"><script src="https://giscus.app/client.js" data-repo="thetechstack/thetechstack.github.io" data-repo-id="R_kgDOG6Ti1Q" data-category="Announcements" data-category-id="DIC_kwDOG6Ti1c4COQtm" data-mapping="pathname" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="zh-CN" crossOrigin="anonymous" async></script></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一、如何使用-netns"><span class="level-left"><span class="level-item">1</span><span class="level-item">一、如何使用 netns</span></span></a></li><li><a class="level is-mobile" href="#二、内核中-namespace-的定义"><span class="level-left"><span class="level-item">2</span><span class="level-item">二、内核中 namespace 的定义</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-归属到-namespace-的东东"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">2.1 归属到 namespace 的东东</span></span></a></li><li><a class="level is-mobile" href="#2-2-网络-namespace-定义"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">2.2 网络 namespace 定义</span></span></a></li></ul></li><li><a class="level is-mobile" href="#三、网络-namespace-的创建"><span class="level-left"><span class="level-item">3</span><span class="level-item">三、网络 namespace 的创建</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-进程与网络命名空间"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">3.1 进程与网络命名空间</span></span></a></li><li><a class="level is-mobile" href="#3-2-命名空间内的网络子系统初始化"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">3.2 命名空间内的网络子系统初始化</span></span></a></li><li><a class="level is-mobile" href="#3-3-添加设备"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">3.3 添加设备</span></span></a></li></ul></li><li><a class="level is-mobile" href="#四、在-namespace-下的网络收发"><span class="level-left"><span class="level-item">4</span><span class="level-item">四、在 namespace 下的网络收发</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-socket-与网络命名空间"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">4.1 socket 与网络命名空间</span></span></a></li><li><a class="level is-mobile" href="#4-2-网络包的收发过程"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">4.2 网络包的收发过程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#五、结论"><span class="level-left"><span class="level-item">5</span><span class="level-item">五、结论</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg"></figure><p class="is-size-6 is-block">公众号：面向问题编程</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">34</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">11</p></a></div></div></nav></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3/"><span class="level-start"><span class="level-item">一文了解</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"><span class="level-start"><span class="level-item">技术架构</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BB%BC%E8%BF%B0/"><span class="level-start"><span class="level-item">综述</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%97%AE%E9%A2%98/"><span class="level-start"><span class="level-item">问题</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="面向问题编程" height="28"></a><p class="is-size-7"><span>&copy; 2022 面向问题编程</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lg-zoom@1.3.0/dist/lg-zoom.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>