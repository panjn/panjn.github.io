<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>一文了解Kubernetes控制器Deployment - 面向问题编程</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="面向问题编程"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="面向问题编程"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="经过前面不少文章的铺垫，终于可以写这个大家都感兴趣的话题了，在前面两篇文章，我们讲了Kubernetes里的 Pod和 副本集ReplicaSet (RS) 这两个API对象。知道了Pod是Kubernetes里的最小调度单元，ReplicaSet则是控制Pod副本数的一个基础控制器。文章最后留下了一个话题：  Kubernetes里一般使用Deployment控制器而不是直接使用ReplicaS"><meta property="og:type" content="blog"><meta property="og:title" content="一文了解Kubernetes控制器Deployment"><meta property="og:url" content="https://www.heapoverflow.cn/pages/wiki-k8s-deployment/"><meta property="og:site_name" content="面向问题编程"><meta property="og:description" content="经过前面不少文章的铺垫，终于可以写这个大家都感兴趣的话题了，在前面两篇文章，我们讲了Kubernetes里的 Pod和 副本集ReplicaSet (RS) 这两个API对象。知道了Pod是Kubernetes里的最小调度单元，ReplicaSet则是控制Pod副本数的一个基础控制器。文章最后留下了一个话题：  Kubernetes里一般使用Deployment控制器而不是直接使用ReplicaS"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.heapoverflow.cn/img/wiki-k8s-deployment/0.jpg"><meta property="article:published_time" content="2022-04-04T04:08:02.491Z"><meta property="article:modified_time" content="2022-04-04T07:59:14.011Z"><meta property="article:author" content="面向问题编程"><meta property="article:tag" content="Kubernetes"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/wiki-k8s-deployment/0.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.heapoverflow.cn/pages/wiki-k8s-deployment/"},"headline":"一文了解Kubernetes控制器Deployment","image":["https://www.heapoverflow.cn/img/wiki-k8s-deployment/0.jpg"],"datePublished":"2022-04-04T04:08:02.491Z","dateModified":"2022-04-04T07:59:14.011Z","author":{"@type":"Person","name":"面向问题编程"},"publisher":{"@type":"Organization","name":"面向问题编程","logo":{"@type":"ImageObject","url":"https://www.heapoverflow.cn/img/logo.svg"}},"description":"经过前面不少文章的铺垫，终于可以写这个大家都感兴趣的话题了，在前面两篇文章，我们讲了Kubernetes里的 Pod和 副本集ReplicaSet (RS) 这两个API对象。知道了Pod是Kubernetes里的最小调度单元，ReplicaSet则是控制Pod副本数的一个基础控制器。文章最后留下了一个话题：  Kubernetes里一般使用Deployment控制器而不是直接使用ReplicaS"}</script><link rel="canonical" href="https://www.heapoverflow.cn/pages/wiki-k8s-deployment/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-ETGL163DQH" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-ETGL163DQH');</script><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-6757924689439593" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="面向问题编程" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories/%E9%97%AE%E9%A2%98/">问题</a><a class="navbar-item" href="/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/">技术架构</a><a class="navbar-item" href="/categories/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3/">一文了解</a></div><div class="navbar-end"><a class="navbar-item" rel="noopener" title="分类" href="/categories">分类</a><a class="navbar-item" rel="noopener" title="标签" href="/tags">标签</a><a class="navbar-item" rel="noopener" title="归档" href="/archives">归档</a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/wiki-k8s-deployment/0.jpg" alt="一文了解Kubernetes控制器Deployment"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-04T04:08:02.491Z" title="2022/4/4 下午12:08:02">2022-04-04</time>发表</span><span class="level-item"><time dateTime="2022-04-04T07:59:14.011Z" title="2022/4/4 下午3:59:14">2022-04-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3/">一文了解</a></span><span class="level-item">29 分钟读完 (大约4332个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">一文了解Kubernetes控制器Deployment</h1><div class="content"><p>经过前面不少文章的铺垫，终于可以写这个大家都感兴趣的话题了，在前面两篇文章，我们讲了<code>Kubernetes</code>里的 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&mid=2247485464&idx=1&sn=00ca443bbcd4b2996efdede396b6c667&chksm=fa80d98fcdf7509944d63f618264e36cd8082a77e23aa36428a3d57a2f4189bcce4e52986967&token=845896787&lang=zh_CN&scene=21#wechat_redirect"><strong>Pod</strong></a>和 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&mid=2247485541&idx=1&sn=59d41bef81615420319b9a721a78ecee&chksm=fa80d9f2cdf750e4250ee59d842501a55375c4c8eacf971eb72adbc3a3cad27259cbd6c27200&token=845896787&lang=zh_CN&scene=21#wechat_redirect"><strong>副本集ReplicaSet (RS)</strong></a> 这两个<code>API</code>对象。知道了<code>Pod</code>是<code>Kubernetes</code>里的最小调度单元，<code>ReplicaSet</code>则是控制<code>Pod</code>副本数的一个基础控制器。文章最后留下了一个话题：</p>
<blockquote>
<p>Kubernetes里一般使用Deployment控制器而不是直接使用ReplicaSet，Deployment是一个管理ReplicaSet并提供水平扩展&#x2F;收缩、Pod声明式更新、应用的版本管理以及许多其他功能的更高级的控制器。</p>
</blockquote>
<p>所以部署到<code>Kubernetes</code>集群里的<code>Go</code>项目就是通过<code>Deployment</code>这个控制器实现应用的<strong>水平扩展&#x2F;收缩</strong>和<strong>更应用新管理</strong>的，它通过自己的控制循环确保集群里当前的状态始终等于<code>Deployment</code>对象定义的期望状态。</p>
<span id="more"></span>

<p>我会使用《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&mid=2247485328&idx=1&sn=1615cbb8d60b0df38cf59375cca6cef2&chksm=fa80d607cdf75f11cf025730a492646f3ea375a81fca5e70c46703f37aa2e7d929950693cae6&token=845896787&lang=zh_CN&scene=21#wechat_redirect"><strong>Kubernetes入门实践–部署运行Go项目</strong></a>》文章里用过的项目作为演示项目，演示<code>Kubernetes</code>怎么对应用服务进行水平扩容、发版更新、版本回滚等操作，在演示的过程中一起探讨下面几个话题：</p>
<ul>
<li>什么是<code>Deployment</code>控制器</li>
<li><code>Deployment</code>的工作原理。</li>
<li>怎么创建<code>Deployment</code>。</li>
<li>如何使用<code>Deployment</code>滚动更新应用。</li>
<li>如何使用<code>Deployment</code>进行应用的版本回滚。</li>
</ul>
<h2 id="什么是Deployment"><a href="#什么是Deployment" class="headerlink" title="什么是Deployment"></a>什么是Deployment</h2><p>在<code>Kubernetes</code>中，建议使用<code>Deployment</code>来部署<code>Pod</code> 和 <code>RS</code>，因为它具有很多方便管理集群的内置功能，比如：</p>
<ul>
<li>轻松部署RS（副本集）</li>
<li>清理不再需要的旧版RS</li>
<li>扩展&#x2F;缩小RS里的Pod数量</li>
<li>动态更新<code>Pod</code>（根据Pod模板定义的更新用新Pod替换旧Pod）</li>
<li>回滚到以前的<code>Deployment</code>版本</li>
<li>保证服务的连续性</li>
</ul>
<p>以下面这个<code>Deployment</code>对象的定义为例，第一部分是自己的元信息（name, labels）的定义，第二部分是<code>ReplicaSet</code>对象的定义(spec.replica&#x3D;3….)，<code>ReplicaSet</code>定义里又包含了<code>Pod</code>的定义(spec.template)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: <span class="number">3</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:<span class="number">1.7</span><span class="number">.9</span></span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>在具体的实现上，这个<code>Deployment</code>，与<code>ReplicaSet</code>，以及<code>Pod</code> 的关系和管理层级我们可以用一张图把它描述出来：</p>
<p><img src="/img/wiki-k8s-deployment/0.jpg" alt="Deployment、RS和Pod的关系"></p>
<p>Deployment、RS和Pod的关系</p>
<h2 id="Deployment的工作原理"><a href="#Deployment的工作原理" class="headerlink" title="Deployment的工作原理"></a>Deployment的工作原理</h2><p><code>Kubernetes</code>里有很多种控制器，每一个控制器，都以独有的方式负责某种编排功能。Deployment，正是这些控制器中的一种。它们都遵循 Kubernetes 项目中的一个通用编排模式，即：控制循环（control loop），每种控制器负责的编排功能就是它们自己在控制循环里实现的逻辑。</p>
<p>接下来，还是以上面定义的<code>Deployment</code> 为例，我和你简单描述一下的工作原理：</p>
<ul>
<li>Deployment 控制器从 Etcd 中获取到所有携带了”app: nginx”标签的 Pod，然后统计它们的数量，这就是实际状态；</li>
<li>Deployment 对象的 Replicas 字段的值就是期望状态，Deployment 控制器将两个状态做比较；</li>
<li>根据比较结果，<code>Deployment</code>确定是创建 Pod，还是删除已有的 Pod，还是什么不干；</li>
</ul>
<p>这是针对<code>Pod</code>副本数的编排，至于<code>Pod</code>的动态更新和<code>Deployment</code>对象版本的回滚文章下面再说。总而言之，控制器的核心思想就是通过控制循环不断地将实际状态调谐成定义的期望状态，一旦期望状态有更新就会触发控制循环里的调谐逻辑。</p>
<h2 id="怎么创建Deployment"><a href="#怎么创建Deployment" class="headerlink" title="怎么创建Deployment"></a>怎么创建Deployment</h2><p>创建<code>Deployment</code>前需要先声明它的对象定义，我们拿以前文章《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&mid=2247485328&idx=1&sn=1615cbb8d60b0df38cf59375cca6cef2&chksm=fa80d607cdf75f11cf025730a492646f3ea375a81fca5e70c46703f37aa2e7d929950693cae6&token=845896787&lang=zh_CN&scene=21#wechat_redirect"><strong>Kubernetes入门实践–部署运行Go项目</strong></a>》里用到过的<code>Deployment</code>定义简单解释下每部分的含义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata: # Deployment的元数据</span><br><span class="line">  name: my-go-app</span><br><span class="line">spec:</span><br><span class="line">  replicas: <span class="number">1</span> # ReplicaSet部分的定义</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: go-app</span><br><span class="line">  template: # Pod 模板的定义</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: go-app</span><br><span class="line">    spec: # Pod里容器相关的定义</span><br><span class="line">      containers:</span><br><span class="line">        - name: go-app-container</span><br><span class="line">          image: kevinyan001/kube-go-app</span><br><span class="line">          resources:</span><br><span class="line">            limits:</span><br><span class="line">              memory: <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">              cpu: <span class="string">&quot;100m&quot;</span></span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: <span class="number">3000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>apiVersion 声明了对象的API版本，Kubernetes会去对应的包里加载库文件。</li>
<li>kind声明对象的种类，其实就是告诉Kubernetes去加载什么对象。</li>
<li>metadata就是我们这个对象的元数据。</li>
<li>spec.replicas 定义副本集有多少个Pod副本，而spec.selectors则是副本集匹配Pod的规则。</li>
<li>spec.template是Pod模板的定义，其中的内容就是一个完整的Pod对象的定义。</li>
<li>spec.template.spec是关于Pod里容器相关的定义。</li>
</ul>
<p>具体里面每个字段的意思和用途我就不多说了，前面的文章里都讲过，重点强调一下容器配置里<strong>limits.memory</strong>的<code>128Mi</code>代表的是内存分配给容器128兆，而<strong>limits.cpu</strong>的1000m &#x3D; 1核心。100m就是分配给容器0.1核，这个在自己电脑上实践的时候尽量别分配太大，不然根本启动不起来。</p>
<p>写好声明文件后，使用<code>kubectl create</code>命令创建<code>Deployment</code>对象，<code>Kubernetes</code>里所有的API对象都是这么创建的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  kubectl create -f deployment.yaml --record</span><br><span class="line">deployment.apps/my-go-app created</span><br><span class="line">➜   </span><br></pre></td></tr></table></figure>

<p>对于在笔记本上实践的同学，需要先安装Minikube，具体的安装步骤可以参考：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&mid=2247485235&idx=1&sn=0cdd31c25b13790b336e0a8222f00b64&chksm=fa80d6a4cdf75fb27a64c7f06f9a33ed4e644624d3fcf73d791274d03b071467ebb4e292ac95&token=1401073673&lang=zh_CN&scene=21#wechat_redirect">Minikube-运行在笔记本上的Kubernetes集群</a>。</p>
<p>在继续使用<code>Deployment</code>进行更高级的编排工作前，我们先用下面两个命令确保一下<code>Deployment</code>的运行状态：</p>
<ul>
<li><p><strong>kubectl rollout status deployment</strong> 告诉我们<code>Deployment</code>对象的状态变化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl rollout status deployment my-go-app</span><br><span class="line">deployment <span class="string">&quot;my-go-app&quot;</span> successfully rolled out</span><br></pre></td></tr></table></figure></li>
<li><p><strong>kubectl get deployment</strong> 显示期望的副本数和正在更新的副本数，以及当前可提供服务的<code>Pod</code>数量。因为我们在定义里只指定了一个副本，所以当前只有一个<code>Pod</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployment my-go-app</span><br><span class="line">NAME        READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">my-go-app   <span class="number">1</span>/<span class="number">1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">13</span>m</span><br></pre></td></tr></table></figure></li>
<li><p><strong>kubectl get replicaset</strong> 查看<code>Deployment</code>为Pod创建的<code>ReplicaSet</code>的状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get replicaset          </span><br><span class="line">NAME                   DESIRED   CURRENT   READY   AGE</span><br><span class="line">my-go-app<span class="number">-864496b</span>67b   <span class="number">1</span>         <span class="number">1</span>         <span class="number">1</span>       <span class="number">19</span>m</span><br></pre></td></tr></table></figure>

<p>默认情况下，Deployment会将pod-template-hash添加到它创建的<code>ReplicaSet</code>的名称中。比如这里的<strong>my-go-app-864496b67b</strong></p>
</li>
<li><p>最后 <strong>kubectl get pod</strong> 命令可以查看<code>ReplicaSet</code>创建出来的<code>Pod</code>副本的状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                         READY   STATUS             RESTARTS   AGE</span><br><span class="line">my-go-app<span class="number">-864496b</span>67b-ctkf9   <span class="number">1</span>/<span class="number">1</span>     Running            <span class="number">0</span>          <span class="number">25</span>m</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="使用Deployment滚动更新应用"><a href="#使用Deployment滚动更新应用" class="headerlink" title="使用Deployment滚动更新应用"></a>使用Deployment滚动更新应用</h2><p><code>Deployment</code> 通过**”控制器模式”<strong>，来操作<code>ReplicaSet</code> 的个数和属性，进而实现</strong>“水平扩展 &#x2F; 收缩” **和 **”滚动更新” **这两个编排动作。</p>
<h3 id="水平扩展-x2F-收缩"><a href="#水平扩展-x2F-收缩" class="headerlink" title="水平扩展&#x2F;收缩"></a>水平扩展&#x2F;收缩</h3><p>“水平扩展 &#x2F; 收缩”非常容易实现，<code>Deployment</code> 只需要修改它所控制的<code>ReplicaSet</code> 的 <code>Pod</code> 副本个数就可以了。比如，把这个值从 1 改成 3，那么 <code>Deployment</code> 所对应的 <code>ReplicaSet</code>，就会根据修改后的值自动创建两个新的<code>Pod</code>，”水平收缩”则反之。这个操作的指令也非常简单，就是 <strong>kubectl scale</strong>，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl scale --replicas=<span class="number">3</span> deployment my-go-app --record</span><br><span class="line">deployment.apps/my-go-app scaled</span><br></pre></td></tr></table></figure>

<p>如果你手快点还能通过上面说的命令 <strong>kubectl rollout status deployment my-go-app</strong> 看到扩展过程中<code>Deployment</code>对象的状态变化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout status deployment my-go-app    </span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">&quot;my-go-app&quot;</span> rollout to finish: <span class="number">1</span> of <span class="number">3</span> updated replicas are available...</span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">&quot;my-go-app&quot;</span> rollout to finish: <span class="number">2</span> of <span class="number">3</span> updated replicas are available...</span><br><span class="line">deployment <span class="string">&quot;my-go-app&quot;</span> successfully rolled out</span><br></pre></td></tr></table></figure>

<p>可以通过下面的命令观察到ReplicaSet的Name没有发生变化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜   kubectl get replicaset                         </span><br><span class="line">NAME                   DESIRED   CURRENT   READY   AGE</span><br><span class="line">my-go-app<span class="number">-864496b</span>67b   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>       <span class="number">53</span>m</span><br></pre></td></tr></table></figure>

<p>这证明了 <code>Deployment</code>水平扩展和收缩副本集是不会创建新的ReplicaSet的，但是涉及到Pod模板的更新后，比如更改容器的镜像，那么Deployment会用创建一个新版本的ReplicaSet用来替换旧版本。</p>
<h3 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h3><p>在上面的<code>Deployment</code>定义里，Pod模板里的容器镜像设置的是<strong>kevinyan001&#x2F;kube-go-app</strong>，接下来比如我们的<code>Go</code>项目代码更新了，用最新的代码打包了镜像 <strong>kevinyan001&#x2F;kube-go-app:v0.1</strong>，部署Go项目的新镜像的过程就会触发<code>Deployment</code>的滚动更新。</p>
<p>有两种方式更新镜像，一种是更新<code>deployment.yaml</code>里的镜像名称，然后执行 <strong>kubectl apply -f deployment.yaml</strong>。一般公司里的<code>Jenkins</code>等持续继承工具用的就是这种方式。还有一种就是使用<strong>kubectl set image</strong> 命令，为了方便演示我们这里就是用第二种方式进行<code>Pod</code>的滚动更新。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  kubectl <span class="built_in">set</span> image deployment my-go-app go-app-container=kevinyan001/kube-go-app:v0<span class="number">.1</span> --record</span><br><span class="line">deployment.apps/my-go-app image updated</span><br></pre></td></tr></table></figure>

<p>执行滚动更新后通过命令行查看<code>ReplicaSet</code>的状态会发现<code>Deployment</code>用新版本的<code>ReplicaSet</code>对象替换旧版本对象的过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  kubectl get replicaset                                                                </span><br><span class="line">NAME                   DESIRED   CURRENT   READY   AGE</span><br><span class="line">my-go-app<span class="number">-6749</span>dbc697   <span class="number">3</span>         <span class="number">3</span>         <span class="number">2</span>       <span class="number">19</span>s</span><br><span class="line">my-go-app<span class="number">-864496b</span>67b   <span class="number">1</span>         <span class="number">1</span>         <span class="number">1</span>       <span class="number">72</span>m</span><br><span class="line">➜  kubectl get replicaset</span><br><span class="line">NAME                   DESIRED   CURRENT   READY   AGE</span><br><span class="line">my-go-app<span class="number">-6749</span>dbc697   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>       <span class="number">24</span>s</span><br><span class="line">my-go-app<span class="number">-864496b</span>67b   <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>       <span class="number">72</span>m</span><br></pre></td></tr></table></figure>

<p>通过这个Deployment的Events可以查看到这次滚动更新的详细过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  kubectl describe deployment my-go-app</span><br><span class="line">Name:                   my-go-app</span><br><span class="line">Namespace:              <span class="keyword">default</span></span><br><span class="line">CreationTimestamp:      Sat, <span class="number">29</span> Aug <span class="number">2020</span> <span class="number">00</span>:<span class="number">31</span>:<span class="number">56</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">Events:</span><br><span class="line">.....</span><br><span class="line">  Normal  ScalingReplicaSet  <span class="number">37</span>h                deployment-controller  Scaled up replica <span class="built_in">set</span> my-go-app<span class="number">-6749</span>dbc697 to <span class="number">1</span></span><br><span class="line">  Normal  ScalingReplicaSet  <span class="number">37</span>h                deployment-controller  Scaled down replica <span class="built_in">set</span> my-go-app<span class="number">-864496b</span>67b to <span class="number">2</span></span><br><span class="line">  Normal  ScalingReplicaSet  <span class="number">37</span>h                deployment-controller  Scaled up replica <span class="built_in">set</span> my-go-app<span class="number">-6749</span>dbc697 to <span class="number">2</span></span><br><span class="line">  Normal  ScalingReplicaSet  <span class="number">37</span>h (x2 over <span class="number">37</span>h)  deployment-controller  Scaled down replica <span class="built_in">set</span> my-go-app<span class="number">-864496b</span>67b to <span class="number">1</span></span><br><span class="line">  Normal  ScalingReplicaSet  <span class="number">37</span>h                deployment-controller  Scaled up replica <span class="built_in">set</span> my-go-app<span class="number">-6749</span>dbc697 to <span class="number">3</span></span><br><span class="line">  Normal  ScalingReplicaSet  <span class="number">37</span>h                deployment-controller  Scaled down replica <span class="built_in">set</span> my-go-app<span class="number">-864496b</span>67b to <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>当你修改了<code>Deployment</code>里的<code>Pod</code>定义之后，<code>Deployment</code> 会使用这个修改后的 <code>Pod</code> 模板，创建一个新的 <code>ReplicaSet</code>（hash&#x3D;6749dbc697），这个新的<code>ReplicaSet</code> 的初始<code>Pod</code>副本数是：0。然后<code>Deployment</code> 开始将这个新的<code>ReplicaSet</code>所控制的<code>Pod</code> 副本数从 0 个变成 1 个，即：**”水平扩展”<strong>出一个副本。紧接着<code>Deployment</code>又将旧的 <code>ReplicaSet</code>（hash&#x3D;864496b67b）所控制的旧 Pod 副本数减少一个，即：</strong>“水平收缩”**成两个副本。如此交替进行就完成了这一组<code>Pod</code> 的版本升级过程。像这样，将一个集群中正在运行的多个 <code>Pod</code> 版本，交替地逐一升级的过程，就是 **”滚动更新”**。</p>
<p>用示意图描述这个过程的话就像下图这样</p>
<p><img src="/img/wiki-k8s-deployment/1.jpg" alt="Deployment滚动更新的过程"></p>
<p>Deployment滚动更新的过程</p>
<p>为了保证服务的连续性，<code>Deployment</code> 还会确保，在任何时间窗口内，只有指定比例的<code>Pod</code> 处于离线状态。同时，它也会确保，在任何时间窗口内，只有指定比例的新 <code>Pod</code> 被创建出来。这两个比例的值都是可以配置的，默认都是期望状态里<code>spec.relicas</code>值的 25%。所以，在上面这个 <code>Deployment</code> 的例子中，它有 3 个 <code>Pod</code> 副本，那么控制器在“滚动更新”的过程中永远都会确保至少有 2 个<code>Pod</code> 处于可用状态，至多只有 4 个 <code>Pod</code> 同时存在于集群中。这个策略可以通过<code>Deployment</code> 对象的一个字段，<strong>RollingUpdateStrategy</strong>来设置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">...</span><br><span class="line">spec:</span><br><span class="line">...</span><br><span class="line">  strategy:</span><br><span class="line">    type: RollingUpdate</span><br><span class="line">    rollingUpdate:</span><br><span class="line">      maxSurge: <span class="number">1</span></span><br><span class="line">      maxUnavailable: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="回滚Deployment版本"><a href="#回滚Deployment版本" class="headerlink" title="回滚Deployment版本"></a>回滚Deployment版本</h2><p>上面执行变更命令的时候都使用了<strong>--record</strong> 参数，这个参数能让<code>Kubernetes</code>在这个<code>Deployment</code>的变更记录里记录上产生变更当时执行的命令。</p>
<p>执行<strong>kubectl rollout history deployment my-go-app</strong> 就能看到这个<code>Deployment</code>的更新记录：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  kubectl rollout history deployment my-go-app                                   </span><br><span class="line">deployment.apps/my-go-app </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line"><span class="number">1</span>         kubectl scale deployment my-go-app --replicas=<span class="number">3</span> --record=<span class="literal">true</span></span><br><span class="line"><span class="number">2</span>         kubectl <span class="built_in">set</span> image deployment my-go-app go-app-container=kevinyan001/kube-go-app:v0<span class="number">.1</span> --record=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>假如刚才那个滚动更新的Go项目镜像有问题，我们想回退到以前的版本。借助<strong>--record</strong>参数帮我们记录的执行命令和更新记录里的修订号就可以找到想要回滚的版本修订号。</p>
<p>一旦确定了修订号后我们<strong>kubectl rollout undo</strong>命令就能完成<code>Deployment</code>对象的版本回滚。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout undo  deployment my-go-app --to-revision=<span class="number">1</span></span><br><span class="line">deployment.apps <span class="string">&quot;my-go-app&quot;</span></span><br></pre></td></tr></table></figure>

<p>执行完后我们会发现一个非常有意思的事情，以前那个版本的<code>ReplicaSet</code>(hash&#x3D;864496b67b)的Pod的数又变回了3，新<code>ReplicaSet</code>(hash&#x3D;6749dbc697)的Pod数变成了0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get rs</span><br><span class="line">NAME                   DESIRED   CURRENT   READY   AGE</span><br><span class="line">my-go-app<span class="number">-6749</span>dbc697   <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>       <span class="number">3</span>m33s</span><br><span class="line">my-go-app<span class="number">-864496b</span>67b   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>       <span class="number">4</span>m30s</span><br></pre></td></tr></table></figure>

<p>证明<code>Deployment</code>在上次滚动更新后并不会把旧版本的<code>ReplicaSet</code>删掉，而是留着回滚的时候用，所以<code>ReplicaSet</code>相当于一个基础设施层面的应用的版本管理。</p>
<p>回滚后在看变更记录，发现已经没有修订号1的内容了，而是多了修订号为3的内容，这个版本的变更内容其实就是回滚前修订号1里的变更内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl rollout history deployment my-go-app   </span><br><span class="line">deployment.apps/my-go-app </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line"><span class="number">2</span>         kubectl <span class="built_in">set</span> image deployment my-go-app go-app-container=kevinyan001/kube-go-app:v0<span class="number">.1</span> --record=<span class="literal">true</span></span><br><span class="line"><span class="number">3</span>         kubectl scale deployment my-go-app --replicas=<span class="number">3</span> --record=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="控制ReplicaSet的版本数量"><a href="#控制ReplicaSet的版本数量" class="headerlink" title="控制ReplicaSet的版本数量"></a>控制ReplicaSet的版本数量</h2><p>你可能已经想到了一个问题：我们对<code>Deployment</code> 进行的每一次更新操作，都会生成一个新的<code>ReplicaSet</code> 对象，是不是有些多余，甚至浪费资源？所以，Kubernetes 项目还提供了一个指令，使得我们对 Deployment 的多次更新操作，最后只生成一个<code>ReplicaSet</code>对象。具体的做法是，在更新<code>Deployment</code>前，你要先执行一条 <strong>kubectl rollout pause</strong> 指令。它的用法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl rollout pause deployment my-go-app</span><br><span class="line">deployment.apps/my-go-app paused</span><br></pre></td></tr></table></figure>

<p>这个命令的作用，是让这个<code>Deployment</code>进入了一个”暂停”状态。由于此时<code>Deployment</code>正处于“暂停”状态，所以我们对<code>Deployment</code>的所有修改，都不会触发新的“滚动更新”，也不会创建新的<code>ReplicaSet</code>。而等到我们对 <code>Deployment</code> 修改操作都完成之后，只需要再执行一条 <strong>kubectl rollout resume</strong> 指令，就可以把这个 它恢复回来，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl rollout resume deployment my-go-app</span><br><span class="line">deployment.apps/my-go-app resumed</span><br></pre></td></tr></table></figure>

<p>随着应用版本的不断增加，<code>Kubernetes</code>会为同一个<code>Deployment</code>保存很多不同的<code>ReplicaSet</code>。<code>Deployment</code> 对象有一个字段，叫作 <strong>spec.revisionHistoryLimit</strong>，就是 <code>Kubernetes</code> 为 <code>Deployment</code> 保留的”历史版本”个数。如果把它设置为 0，就再也不能做回滚操作了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Kubernetes</code> 项目对 <code>Deployment</code> 的设计，代替我们完成了对<strong>应用</strong>的抽象，让我们可以用一个<code>Deployment</code> 对象来描述应用，使用 <strong>kubectl rollout</strong> 命令控制应用的版本。</p>
<p><code>Deployment</code> 还会保证服务的连续性，确保滚动更新时在任何时间窗口内，只有指定比例的<code>Pod</code> 处于离线状态，同时也只有指定比例的新 <code>Pod</code> 被创建出来，这样就保证了服务能平滑更新。用<code>Go</code>写的<code>HTTP</code>服务举例子来说，我们不需要再在代码里自己实现<code>HTTP Server</code>平滑重启的功能，因为这些功能都由<code>Deployment</code>在应用抽象层面替我们实现了。</p>
<p>希望大家都能跟着今天文章里的演示，掌握<code>Deployment</code>的提供的各种功能的用法。文章里我用的镜像已经上传到<strong>DockerHub</strong>上了，创建<code>Deployment</code>对象时会自动去DockerHub上拉取。如果网络受限，拉取不了镜像，可以在文章下面留言或者公众号私信我获取项目的源码和构建镜像用的<code>Dockerfile</code>。</p>
<article class="message message-immersive is-primary">
<div class="message-body">
<i class="fas fa-globe-asia mr-2"></i>本文来自
<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&mid=2247485643&idx=1&sn=6460bf2e170e4b2e8ebb2882bfe7c60f&chksm=fa80d95ccdf7504ad9b5e3ba7ad3dad6a25347a7b0aad4636523cb1ba878cebbc480bf2153a0&scene=178&cur_album_id=1394839706508148737#rd"> 网管叨bi叨</a>.
</div>
</article>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Kubernetes/">Kubernetes</a></div><!--!--><div><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6757924689439593" crossOrigin="anonymous"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6757924689439593" data-ad-slot="2352785969"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/pages/practice-meitun-k8s-1/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Kubernetes如何改变美团的云基础设施？</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/pages/wiki-k8s-controller/"><span class="level-item">一文了解Kubernetes控制器模型</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div style="width:100%"><script src="https://giscus.app/client.js" data-repo="thetechstack/thetechstack.github.io" data-repo-id="R_kgDOG6Ti1Q" data-category="Announcements" data-category-id="DIC_kwDOG6Ti1c4COQtm" data-mapping="pathname" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="zh-CN" crossOrigin="anonymous" async></script></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#什么是Deployment"><span class="level-left"><span class="level-item">1</span><span class="level-item">什么是Deployment</span></span></a></li><li><a class="level is-mobile" href="#Deployment的工作原理"><span class="level-left"><span class="level-item">2</span><span class="level-item">Deployment的工作原理</span></span></a></li><li><a class="level is-mobile" href="#怎么创建Deployment"><span class="level-left"><span class="level-item">3</span><span class="level-item">怎么创建Deployment</span></span></a></li><li><a class="level is-mobile" href="#使用Deployment滚动更新应用"><span class="level-left"><span class="level-item">4</span><span class="level-item">使用Deployment滚动更新应用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#水平扩展-x2F-收缩"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">水平扩展/收缩</span></span></a></li><li><a class="level is-mobile" href="#滚动更新"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">滚动更新</span></span></a></li></ul></li><li><a class="level is-mobile" href="#回滚Deployment版本"><span class="level-left"><span class="level-item">5</span><span class="level-item">回滚Deployment版本</span></span></a></li><li><a class="level is-mobile" href="#控制ReplicaSet的版本数量"><span class="level-left"><span class="level-item">6</span><span class="level-item">控制ReplicaSet的版本数量</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">7</span><span class="level-item">总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/CPython/"><span class="tag">CPython</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Feed%E6%9C%8D%E5%8A%A1/"><span class="tag">Feed服务</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Knative/"><span class="tag">Knative</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kubernetes/"><span class="tag">Kubernetes</span><span class="tag">23</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux%E7%BD%91%E7%BB%9C/"><span class="tag">Linux网络</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Serverless/"><span class="tag">Serverless</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Yarn/"><span class="tag">Yarn</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/"><span class="tag">分布式一致性</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9C%A8%E7%A6%BB%E7%BA%BF%E6%B7%B7%E9%83%A8/"><span class="tag">在离线混部</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="tag">大数据</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/"><span class="tag">时间序列</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%99%BA%E8%83%BD%E8%BF%90%E7%BB%B4/"><span class="tag">智能运维</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"><span class="tag">编译原理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96/"><span class="tag">网络虚拟化</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"><span class="tag">语言特性</span><span class="tag">2</span></a></div></div></div></div></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg"></figure><p class="is-size-6 is-block">公众号：面向问题编程</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">62</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">16</p></a></div></div></nav></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3/"><span class="level-start"><span class="level-item">一文了解</span></span><span class="level-end"><span class="level-item tag">26</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5/"><span class="level-start"><span class="level-item">技术实践</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"><span class="level-start"><span class="level-item">技术架构</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BB%BC%E8%BF%B0/"><span class="level-start"><span class="level-item">综述</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%97%AE%E9%A2%98/"><span class="level-start"><span class="level-item">问题</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="面向问题编程" height="28"></a><p class="is-size-7"><span>&copy; 2022 面向问题编程</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lg-zoom@1.3.0/dist/lg-zoom.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>